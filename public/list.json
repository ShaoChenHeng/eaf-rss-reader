[{"feed_link": "https://www.with-emacs.com/rss.xml", "feed_title": "with-emacs", "feed_subtitle": "", "feed_article_list": [{"title": "Customize completion-at-point", "link": "https://www.with-emacs.com/posts/tutorials/customize-completion-at-point/", "time": "Sat, 29 Aug 2020 12:02:35 GMT", "author": "clemera", "description": "This post is an overview of text completion in Emacs using completion-at-point\nand how you can customize it. I will assume that you already know some Elisp and\nare familiar with the basics about\n variables: https://with-emacs.com/posts/tutorials/almost-all-you-need-to-know-about-variables/\nand\n hooks: https://with-emacs.com/posts/tutorials/what-you-need-to-know-about-hooks/\n.\nAll examples also assume you use a fairly recent Emacs version (v.26 or later).\nUsage\nThe completion-at-point command prompts the user with a list of completions\nfor buffer text. Usually it is bound to <kbd>M-TAB</kbd> which is sometimes also\nbound to the wrapper command complete-symbol.\nFor editable buffers <kbd>TAB</kbd> is regularly used for indentation but you can also\ncombine indentation and completion on <kbd>TAB</kbd> by configuring\ntab-always-indent:\n;; First try to indent the current line, and if the line\n;; was already indented, then try `completion-at-point'\n(setq tab-always-indent 'complete)\nThe UI for the completion operation is determined by the value of\ncompletion-in-region-function. Completion frameworks like\n helm: https://github.com/emacs-helm/helm/\n,\n ivy: https://github.com/abo-abo/swiper/\n or\n selectrum: https://github.com/raxod502/selectrum\n provide a suitable function for\nthis and set it automatically when you enable their modes.\nAdding completions\nThe completion data gets gathered by running completion-at-point-functions. As\ndiscussed in a\n previous post: https://with-emacs.com/posts/tutorials/what-you-need-to-know-about-hooks/\n you can add functions to hooks buffer locally. This is also what major\nmodes and language server clients like\n eglot: https://github.com/joaotavora/eglot\n or\n lsp-mode: https://github.com/emacs-lsp/lsp-mode\n do to provide their completions.\nIf the local hook fails to return any candidates the global hook runs. You can\nuse this to add your own completions as a fallback. The functions of this hook\nreceive no arguments and should return completion data containing the start and\nend positions of the text to be completed, a completion table and optionally\nsome extra information (see the docstring of completion-at-point-functions for\nmore details).\nHere is useful example that adds file path completion to the hook:\n(autoload 'ffap-file-at-point \"ffap\")\n(defun complete-path-at-point+ ()\n  \"Return completion data for UNIX path at point.\"\n  (let ((fn (ffap-file-at-point))\n        (fap (thing-at-point 'filename)))\n    (when (and (or fn (equal \"/\" fap))\n               (save-excursion\n                 (search-backward fap (line-beginning-position) t)))\n      (list (match-beginning 0)\n            (match-end 0)\n            #'completion-file-name-table :exclusive 'no))))\n(add-hook 'completion-at-point-functions\n          #'complete-path-at-point+\n          'append)\nAfterwards completion-at-point will offer you file completions when your point\nis at a path. This is especially nice with\n selectrum: https://github.com/raxod502/selectrum\n which won’t exit file\ncompletions after each path level so you can conveniently navigate to the path\nlike you would do with find-file.\nThe function above looks for a file path at point. If it finds one it returns\nthe file path boundaries and the completion table. There will be more info about\ncompletion tables in the next section. The no value for :exclusive is\nadded so that other completion-at-point-functions are continued to be\nqueried if the completion table should fail.\nYou can use a similar pattern for any other completion functions you might want\nto add. See for example  this: https://emacs.stackexchange.com/a/15277/9198\nstackexchange answer which shows how to add completions from a custom dictionary\nor  this: https://emacs.stackexchange.com/a/30704/9198\n one which shows an example\nof adding dabbrev candidates as completions.\nCompletion tables\nCompletion tables can have many different formats. A list of strings, an alist,\nan obarray, a hash table or so called dynamic completion table which is a\nfunction. Those table formats can also be used by completing-read which is the\nfunction Emacs commands typically use to prompt a user with a list of\ncompletions.\nThere isn’t much to say about static tables so this section will look at the\nmore interesting dynamic ones. The last example used the already existing\ncompletion-file-name-table function. You need a dynamic table for file\ncompletion because the returned file names will change based on the input path.\nDynamic tables are also useful if you want to configure some custom completion\nbehaviour which the table can control via its metadata. If you call the table\nwith the metadata action argument it should return it, see (info \"(elisp)\nProgrammed Completion\") for the full details.\nThe following example shows how you can add some metadata to completions. Emacs\ncomes with a little helper function complete-with-action which you can use to\nhandle the rest of the API so you only need to care about handling the\nmetadata action:\n(let* ((alist '((\"GNU\" . \"GNU is not Unix\")\n                (\"Emacs\" . \"Eight Megabytes And Constantly Swapping\")))\n       (annotf (lambda (str)\n                 (format \" (%s)\" (cdr (assoc str alist))))))\n  (completing-read \"Candidates: \"\n                   (lambda (str pred action)\n                     (if (eq action 'metadata)\n                         `(metadata\n                           (annotation-function . ,annotf)\n                           (cycle-sort-function . identity)\n                           (display-sort-function . identity))\n                       (complete-with-action action alist str pred)))))\nThe example disables the default sorting behaviour by using the identity\nfunction. It also adds some annotations to describe the candidates in more\ndetail. Note that there is also completion-extra-properties which can also be\nused to configure certain completion properties.\nThere are many more use cases where dynamic tables can be useful see for example\n this: https://emacs.stackexchange.com/a/37446/9198\n stackexchange answer which\nconstructs a completion table with automatic caching.\nClosing words\nThis post only talked about completion-at-point but there are many more useful\nways to complete text in Emacs. One external package worth mentioning in the\ncontext of this post is the popular\n company: https://github.com/company-mode/company-mode\n package which supports\nauto completion.\nCompany also integrates with completion-at-point-functions: The variable\ncompany-backends includes the company-capf backend which provides you the\ncompletion candidates of completion-at-point-functions. There are also some\nextra properties you can add to your completion-at-point-functions which are\npicked up by company. You can inspect the source of elisp-completion-at-point\nor company-capf itself for more details on this.", "shortDescription": "This post is an overview of text completion in Emacs using completion-at-point\nand how you can customize it. I will assu...", "isRead": false}, {"title": "What you Need to Know About Hooks", "link": "https://www.with-emacs.com/posts/tutorials/what-you-need-to-know-about-hooks/", "time": "Sat, 25 Jul 2020 18:45:27 GMT", "author": "clemera", "description": "Hooks are an important mechanism for customizing Emacs. They are used to execute\ncode on certain occasions and are part of any non-trivial Emacs setup. In this\npost you will learn how to use them for your own configurations and about some\npitfalls you might encounter in practice.\nThis post assumes that you already know some basics about Elisp and variables as\ndiscussed\n earlier: https://with-emacs.com/posts/tutorials/almost-all-you-need-to-know-about-variables/\n.\nAll examples also assume you use a fairly recent Emacs version (v.26 or later).\nBasic usage\nHooks are regular variables which hold a function or more commonly a list of\nthem. These functions are called when the hook runs. Here is a typical snippet\nof user configuration:\n(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)\nThe above adds the function executable-make-buffer-file-executable-if-script-p\nto after-save-hook. Afterwards this function gets called each time you save a\nbuffer. If the file is a script (as detected by\n #!: https://en.wikipedia.org/wiki/Shebang_(Unix)\n) the file is made executable.\nTo remove the function again you use remove-hook:\n(remove-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)\nBy convention those variables end with -hook in their name so you can easily\nsearch for them. Because many packages and modes come with their own set of\nhooks it can be hard to track down the more general ones but you can find a list\nof the standard Emacs hooks in the\n manual: https://www.gnu.org/software/emacs/manual/html_node/elisp/Standard-Hooks.html\n.\nIt’s important to mention that you shouldn’t use anonymous functions for your\nhooks because it becomes hard to tell the purpose of a lambda when you inspect\nthe hook at some later point. Another benefit of using named functions is that\nyou can easily remove them by passing their name to remove-hook.\nMajor mode hooks\nIf you want to run setup functions for specific modes you can use major mode\nhooks. These hooks will run when you enter the mode. Note that hooks don’t need\nto be defined ahead of time so you can add functions to them before the\ncorresponding mode is loaded by Emacs.\nSometimes you will come across examples where major mode hooks are used to setup\nkeybindings like this:\n(defun python-key-setup+ ()\n  (local-set-key ...) ...)\n(add-hook 'python-mode-hook #'python-key-setup+)\nWhile this works it will set the key bindings every time a buffer enters the\nmode which isn’t necessary. The local keymap is usually the major mode keymap\nwhich is shared by all buffers which use that mode. You can achieve the same\neffect by defining the bindings only once after the keymap is available:\n(with-eval-after-load 'python\n  (define-key python-mode-map ...))\nBuffer local hooks\nIn the first section executable-make-buffer-file-executable-if-script-p was\nadded to the global hook but often you want to adjust hooks only for specific\nbuffers. You might be tempted to check for buffer names or major modes in your\nhook functions like this:\n(add-hook 'after-save-hook #'after-save-in-some-buffer+)\n(defun after-save-in-some-buffer+ ()\n  (when (string= (buffer-name) ...)\n    ...))\nBut a better way is to adjust the hook variable buffer locally by using the\nlocal argument of add-hook and remove-hook. For example if you want to run\nthe executable-make-buffer-file-executable-if-script-p only in sh-mode\nbuffers you can use:\n(defun sh-mode-setup+ ()\n  (add-hook 'after-save-hook\n            #'executable-make-buffer-file-executable-if-script-p\n            nil 'local))\n(add-hook 'sh-mode-hook #'sh-mode-setup+)\nWhen the major mode sh-mode is entered, sh-mode-setup+ will run and add\nexecutable-make-buffer-file-executable-if-script-p to the buffer local save\nhook.\nUsually you shouldn’t use make-local-variable to make hook variables local\nbecause add-hook automatically handles some things for you: It arranges for a\nfinal t at the end of the local hook list. This will tell run-hooks that the\nglobal hook should run as well. Usually this is what you want because the global\nhook should be expected to run regardless of any additional local setup. Further\nany subsequent calls to add-hook won’t automatically affect the local value\nwhich is useful because there might be some other setup functions running down\nthe chain which don’t expect the hook variable to be local.\nLike with other local variables if you want to get completely rid of the local\nversion you can use kill-local-variable.\nMinor mode hooks\nA common pitfall is to think minor mode hooks work like major mode hooks but\nthere is an important difference: Minor modes run their hooks when you enter\nand when you leave them. This can be used to run additional setup or teardown\ncode. For example if you always want to toggle a mode in tandem with another one\nyou can use something like:\n(add-hook 'visual-fill-column-mode-hook #'visual-fill-column-toggle-wrap+)\n(defun visual-fill-column-toggle-wrap+ ()\n  (adaptive-wrap-prefix-mode\n   (if visual-fill-column-mode 1 -1)))\nThe mode variable visual-fill-column-mode will be t when activating the\nmode.  The example above uses this to activate and deactivate\nadaptive-wrap-prefix-mode accordingly.\nAbnormal hooks\nIn contrast to the normal hooks this post talked about there are also so called\nabnormal hooks which by convention end with -functions in their name. Those\ncan receive additional arguments or their return value is used for further\nprocessing. The exact details need to be described by their documentation. They\nare not as relevant for user configuration but can be very useful when writing\nElisp so you might want to learn more about how to use them (see the\ncomments). Generally the same concepts apply for these hooks and conveniently\nyou can continue to use add-hook or remove-hook for them, too.", "shortDescription": "Hooks are an important mechanism for customizing Emacs. They are used to execute\ncode on certain occasions and are part ...", "isRead": false}, {"title": "Quit Current Context", "link": "https://www.with-emacs.com/posts/tips/quit-current-context/", "time": "Sun, 08 Mar 2020 11:37:56 GMT", "author": "clemera", "description": "This is just a short post sharing one of those commands I use every day and\nwould immediately miss in an uncustomized Emacs session. Have you ever tried to\nquit the minibuffer when point was in another window? Naturally you would try\nhammering <kbd>C-g</kbd> but in stock Emacs the minibuffer stays active and all you\nget are grumpy \"Quit\" messages.\nEmacs comes with the keyboard-escape-quit command which allows more sensible\nquits in certain contexts. One thing I do not like about this command is that\none clause deletes other windows if there are any. I have written my own version\ncombining keyboard-quit and keyboard-escape-quit in a way that fits my\nneeds:\n(defun keyboard-quit-context+ ()\n  \"Quit current context.\nThis function is a combination of `keyboard-quit' and\n`keyboard-escape-quit' with some parts omitted and some custom\nbehavior added.\"\n  (interactive)\n  (cond ((region-active-p)\n         ;; Avoid adding the region to the window selection.\n         (setq saved-region-selection nil)\n         (let (select-active-regions)\n           (deactivate-mark)))\n        ((eq last-command 'mode-exited) nil)\n        (current-prefix-arg\n         nil)\n        (defining-kbd-macro\n          (message\n           (substitute-command-keys\n            \"Quit is ignored during macro defintion, use \\\\[kmacro-end-macro] if you want to stop macro definition\"))\n          (cancel-kbd-macro-events))\n        ((active-minibuffer-window)\n         (when (get-buffer-window \"*Completions*\")\n           ;; hide completions first so point stays in active window when\n           ;; outside the minibuffer\n           (minibuffer-hide-completions))\n         (abort-recursive-edit))\n        (t\n         ;; if we got this far just use the default so we don't miss\n         ;; any upstream changes\n         (keyboard-quit))))\n(global-set-key [remap keyboard-quit] #'keyboard-quit-context+)\nMost notably you can use this command to quit the minibuffer from any other\nwindow. Another thing I added recently is to ignore quits when defining macros.", "shortDescription": "This is just a short post sharing one of those commands I use every day and\nwould immediately miss in an uncustomized Em...", "isRead": false}, {"title": "(Almost) All You Need to Know About Variables", "link": "https://www.with-emacs.com/posts/tutorials/almost-all-you-need-to-know-about-variables/", "time": "Sat, 01 Feb 2020 14:00:01 GMT", "author": "clemera", "description": "This is the start of a series of posts about Emacs Lisp concepts in which I will\ntry to fill some gaps between  beginner resources: http://sachachua.com/blog/p/27144\n and some more advanced concepts. This post assumes that you are\nalready familiar with common Emacs terminology and know how to read and evaluate\nbasic snippets of Emacs Lisp code. Ideally you should also have heard of\nvariable scope and how it works in some other programming language. The examples\nalso assume you use a fairly recent Emacs version (v.25 or later).\nOf course the Elisp manual will tell you everything there is to know but it is\ndesigned for people who already know what they are looking for (and it is really\ngreat for that). Therefore many people ask for resources explaining Elisp\nconcepts at a higher level and reduce the information to the most useful bits.\nThis is my attempt to bring readers in the position of having a good grasp of\nthe basics so they can use them for their own configuration and have an easier\ntime if they need to look up some detail in the manual.\nGlobal Variables\nUser options defined via defcustom and variables defined via defvar or\ndefconst are global. One important aspect about variables declared by\ndefcustom or defvar is that reevaluating them won’t reset the variable if it\nis already bound. For example if you establish a binding for my-var in you\ninit file like this:\n(setq my-var nil)\nThen evaluating the following form won’t reset the variable to t:\n(defvar my-var t)\nNote that there is one exception: If you evaluate the above declaration via\n<kbd>C-M-x</kbd> which calls eval-defun the value will be reset to t. This way\nyou can enforce setting the value if you need to. This behavior is intentional:\nAs you might know many features in Emacs are only loaded on demand (autoloaded).\nIf the declarations in those files would reset variables to their default value\nthis would override any settings you made in your init.\nUser Options\nA user option is simply a global variable that was declared with defcustom.\nUnlike variables declared via defvar such a variable is configurable via the\n<kbd>M-x</kbd> <kbd>customize</kbd> interface. As far as I know most people don’t make\nmuch use of it because it feels clunky and once you know how to set variables in\nyour init file there is no compelling reason to use it. One detail many users\naren’t aware of is that setting user options via customize might execute code,\nwhich is sometimes used to run additional setup instructions:\n(defcustom my-option t\n  \"My user option.\"\n  :set (lambda (sym val)\n         (set-default sym val)\n         (message \"Set %s to %s\" sym val)))\nIf you evaluate the above piece of code and change the value using the customize\ninterface via <kbd>M-x</kbd> <kbd>customize-option</kbd> <kbd>RET</kbd> <kbd>my-option</kbd>\n<kbd>RET</kbd>, you will see that the lambda gets called and the message in the echo\narea tells you the symbol and value of the option.\nIn case you use setq in your int file for changing the value of such an option\nthe setter function will not run. To set such an option correctly via Elisp\nyou need to use the function customize-set-variable. Alternatively there are\nvarious versions of csetq macros people use in their configs to automatically\ntake care of this (you can use github code search to discover more sophisticated\nvariants if you like):\n(defmacro csetq (sym val)\n  `(funcall (or (get ',sym 'custom-set) 'set-default) ',sym ,val))\nIf you are using\n use-package: https://github.com/jwiegley/use-package#customizing-variables\n, the\n:custom keyword already handles this for you.\nAfter putting the above code in your init file, you can use csetq to set\nvariables in a way which respect any existing setter functions. You can prove\nthis to yourself by watching the message in the echo area when using this macro\nto change the option defined above:\n(csetq my-option nil)\nDynamic Binding and Lexical Binding\nEven if you have already dealt with other programming languages you might never\nheard of dynamic or lexical binding. This is because most programming languages\ntoday use lexical binding and when you learn about variable scope/lookup there\nis no need to know the difference.\nEmacs Lisp is a bit special in this regard because dynamic binding is the\ndefault and lexical binding needs to be enabled explicitly. This has historical\nreasons and in practice you should always enable lexical binding because it is\nfaster and less error prone. To enable it you simply put the following comment\nline as the first line of your Emacs Lisp file:\n;;; -*- lexical-binding: t; -*-\nAlternatively you can call <kbd>M-x</kbd> <kbd>add-file-local-variable-prop-line</kbd>\nwhich will insert this line for you when you choose the variable\nlexical-binding with value t.\nWhen a file with such a special formatted line gets loaded Emacs will set the\nvariable accordingly, which means the code in that buffer will be loaded with\nlexical binding enabled. Interactively you can use <kbd>M-x</kbd> <kbd>eval-buffer</kbd>\nwhich will also take the lexical binding setting into account.\nNow you know how to enable lexical binding let’s examine what those terms\nactually mean: With dynamic binding the latest binding established during\nprogram execution will be used for variable lookup. You can test this by putting\nthe following code in an empty buffer and execute <kbd>M-x</kbd> <kbd>eval-buffer</kbd>:\n(defun a-exists-only-in-my-body (a)\n  (other-function))\n(defun other-function ()\n  (message \"I see `a', its value is %s\" a))\n(a-exists-only-in-my-body t)\nYou may be surprised to see that the lookup of variable a in other-function\nwill succeed.\nIf you retry the preceding example with the special lexical-binding comment at\nthe top, you will notice that the code will throw a variable is void error\nbecause other-function does not know about the a variable. Coming from other\nprogramming languages this is the behavior you would expect.\nWith lexical binding the scope is defined by the surrounding source code. In\naddition to performance reasons, experience and time have shown that this\nbehavior should be preferred.\nSpecial Variables and Dynamic Binding\nAs you might know let is used to temporary establish local bindings:\n(let ((a \"I'm a\")\n      (b \"I'm b\"))\n  (message \"Hello, %s. Hello %s\" a b))\nHere is the thing: Variables declared via defcustom, defvar or defconst\nare so called special variables and those will continue to use dynamic binding\nregardless if lexical binding is enabled or not:\n;;; -*- lexical-binding: t; -*-\n(defun some-other-function ()\n  (message \"I see `c', its value is: %s\" c))\n(defvar c t)\n(let ((a \"I'm lexically bound\")\n      (c \"I'm special and therefore dynamically bound\"))\n  (some-other-function)\n  (message \"I see `a', its values is: %s\" a))\nTo see both messages in the example above you can switch to the *Messages*\nbuffer using <kbd>C-h</kbd> <kbd>e</kbd>.\nLocal variables bound with let or function arguments will follow the lookup\nrules as defined by the lexical-binding variable, but global variables\ndefined via defvar, defconst or defcustom can be changed deep down the\ncall stack for the duration of the let body!\nThis behavior allows for convenient adhoc customizations and is often used in\nEmacs, which isn’t surprising given that Emacs Lisp started out with dynamic\nbinding being the only option. Here is a common example showing how you can\ntemporary write to some read-only buffer:\n(let ((inhibit-read-only t))\n  (insert ...))\nOr another often seen example to perform case sensitive searches:\n(let ((case-fold-search nil))\n  (some-function-which-uses-search ...))\nDynamic binding allows changing the behavior of functions in ways which the\nauthors of those functions may have never anticipated. It’s a powerful tool and\nit is a great feature for a program that is designed and used like Emacs.\nThere is one caveat you should be aware of: It may happen that you accidentally\nuse a local variable name which is a declared as a special variable elsewhere.\nOne trick to prevent such conflicts is to avoid local variables which have\ndashes in their name. In my current Emacs session this leaves only a handful of\npotential conflicting candidates:\n(let ((vars ()))\n  (mapatoms\n   (lambda (cand)\n     (when (and (boundp cand)\n                (not (keywordp cand))\n                (special-variable-p cand)\n                (not (string-match \"-\"\n                                   (symbol-name cand))))\n       (push cand vars))))\n  vars) ;; => (t obarray noninteractive debugger nil)\nBuffer Local Variables\nEach buffer can have a local binding for a variable. This means any variable\nlookup made while this buffer is current will reveal the buffer local value of\nthat variable instead of the default one. Local variables are an important\nfeature in Emacs, for example they are used by major modes to establish their\nbuffer local behavior and settings. To avoid interfering with each other major\nmodes also kill existing local variables when you enter them.\nYou have already seen a buffer local variable in this post: The special comment\nline for lexical-binding which binds it buffer locally to t. In Emacs such\nbuffer local variables defined in special comment lines are also called file\nlocal variables.\nAny global variable can be shadowed by a buffer local one. Take for example\nthe my-var variable defined in a previous section of this post which you can\nset locally like this:\n(setq-local my-var t)\n;; or (set (make-local-variable 'my-var) t)\nmy-var will be local to the buffer which is current when you evaluate the code\nabove. If you call describe-variable on it, you will see that the\ndocumentation tells you the local value and the global one. Programmatically you\ncan check the local value using buffer-local-value and the default one with\ndefault-value. To remove the local version you could invoke <kbd>M-x</kbd>\n<kbd>kill-local-variable</kbd>.\nAnother important property you need to be aware of is that once a variable is\nbuffer local, any further uses of setq (while this buffer is current) will\ncontinue to set the local value. To set the default value you would need to use\nsetq-default.\nBecause local variables are meant for buffer customization you will use them\nmost often in mode hooks. A typical example would be something like:\n(add-hook 'go-mode-hook\n          (defun go-setup+ ()\n            (setq-local compile-command\n              (if (string-suffix-p \"_test.go\" buffer-file-name)\n                  \"go test -v\"\n                (format \"go run %s\"\n                        (shell-quote-argument\n                         (file-name-nondirectory buffer-file-name)))))))\nThis will set the compile command used by <kbd>M-x</kbd> <kbd>compile</kbd> for go mode\nbuffers.\nAnother important aspect is that some variables are automatically buffer\nlocal. This means as soon as you setq such a variable this will establish a\nlocal binding for the current buffer. This feature shouldn’t be used often\nbecause this implicit behavior isn’t nice but if you want you can create such\nautomatically local variables like this:\n(defvar-local my-automatical-local-var t)\n;; or (make-variable-buffer-local 'my-automatical-local-var)\nThe variable indent-tabs-mode is a built-in example of this. If you would use\nsetq in your init file to change the value of this variable that wouldn’t\naffect the default value at all. Only the value for the buffer that is current\nwhile loading your init file would be changed. Because of that you need to use\nsetq-default to change the default value of indent-tabs-mode.\nClosing Words\nI have tried my best to find a balance between details and a more high level\noverview. Hopefully this helps some souls out there feeling more confident when\nsetting their variables in Emacs. Please leave a comment if you have any\nquestions or suggestions.", "shortDescription": "This is the start of a series of posts about Emacs Lisp concepts in which I will\ntry to fill some gaps between  beginner...", "isRead": false}, {"title": "Using Occur for Search and Replace across Files", "link": "https://www.with-emacs.com/posts/tutorials/using-occur-for-search-and-replace-across-files/", "time": "Fri, 27 Dec 2019 14:00:27 GMT", "author": "clemera", "description": "This post describes how to combine occur with query-replace to search and\nreplace across files and contains some useful Elisp snippets and recommendations\nto improve this workflow.\nThis post is a follow up of the more\ngeneral post about  search and replacement techniques: https://with-emacs.com/posts/editing/search-and-replacement-techniques/\nin Emacs.\nSearch and replace in projects\nTo search with occur across files in projects I recommend the great\n noccur: https://github.com/NicolasPetton/noccur.el\n package. It’s a small package\nthat provides some convenient commands which simplify using the built-in\nmulti-occur for projects and from dired.\nShow context on replace\nAfter a search via <kbd>M-x</kbd> <kbd>noccur-project</kbd> or <kbd>multi-occur</kbd> or any\nother occur variant, you get an occur buffer with results grouped by files the\nmatches where found in. In occur you can enter occur-edit-mode with <kbd>e</kbd>\nwhich makes the search results editable.\nAfter you entered occur-edit-mode you can use query-replace or any editing\ncommands you like to edit the search results. I prefer to see some context\nbefore replacing a match which can be done by setting up some hooks:\n(add-hook 'occur-mode-hook\n          (defun occur-show-replace-context+ ()\n            (add-hook 'replace-update-post-hook\n                      'occur-mode-display-occurrence nil 'local)))\nThe above adds occur-mode-display-occurrence to replace-update-post-hook in\noccur buffers, this way you always see the context when you are queried for the\nreplace.\nOne problem is that occur-mode-display-occurrence messes with the match data\n(Emacs 26.3) which breaks query-replace. To fix this you need to use the\nfollowing advice:\n(define-advice occur-mode-display-occurrence\n    (:around (fun &rest args) save-match-data)\n  (save-match-data\n    (apply fun args)))\nSkip occur title lines for search and replace\nBy default query-replace and isearch won’t skip the header lines which show\nmatch info and therefore shouldn’t be included. To fix this you can use the\nfollowing snippet:\n(add-hook 'occur-mode-hook\n          (defun isearch-occur-setup+ ()\n            (add-function :after-while (local 'isearch-filter-predicate)\n              'occur-isearch-filter-p+)))\n(defun occur-isearch-filter-p+ (beg end)\n  \"Return non-nil if match should be considered.\"\n  (and\n   (save-excursion\n     ;; always omit first line wich contains summary info and in multi-occur it\n     ;; has no occur-title property and isn't read only\n     (goto-char beg)\n     (not (= (point-min) (line-beginning-position))))\n   ;; omit the other occur header lines\n   (not (or (get-text-property beg 'occur-title)\n            (get-text-property end 'occur-title)))))\nThe above adds a local filter predicate for occur which takes care of omitting\nthe header lines for search and replace operations. To learn more about how this\nworks you can find more info in the docstrings of add-function and\nisearch-filter-predicate.\nYou could also set the variable isearch-filter-predicate buffer locally using\nsetq-local but using add-function like shown above has the benefit of\nautomatically respecting other filter predicates you might have setup.\nAuto-save edits\nAfter you are done with your edits you can get back to regular occur-mode with\n<kbd>C-c C-c</kbd>. The modified buffers are not automatically saved to disk but if\nyou would like to do that you can use the following:\n(defvar-local occur-edit-buffers+ nil\n  \"Save buffers in which occur performed changes.\")\n(add-hook 'occur-edit-mode-hook\n          (defun occur-eddit-save-edits+ ()\n            (add-hook 'after-change-functions\n                      'occur-edit-remember-buffer+ nil t)))\n(defun occur-edit-remember-buffer+ (&rest _)\n  (let* ((m (get-text-property (line-beginning-position) 'occur-target))\n         (buf (and (markerp m) (marker-buffer m))))\n    (when buf\n      (pushnew buf occur-edit-buffers+))))\n(define-advice occur-cease-edit (:before () save-edits)\n  (dolist (buf occur-edit-buffers+)\n    (with-current-buffer buf\n      (save-buffer))))", "shortDescription": "This post describes how to combine occur with query-replace to search and\nreplace across files and contains some useful ...", "isRead": false}, {"title": "Prefix command completion", "link": "https://www.with-emacs.com/posts/ui-hacks/prefix-command-completion/", "time": "Fri, 18 Oct 2019 15:00:00 GMT", "author": "clemera", "description": "As a reader of this blog you probably know about\n which-key: https://github.com/justbur/emacs-which-key\n. It is a great package\nwhich helps discovering and remembering keybindings. One thing I miss, is the\noption to choose candidates via completion, which is the goal of this post.\nWhen you press <kbd>C-h</kbd> after a prefix key, Emacs displays a buffer containing\nall the bindings under that prefix. The command which gets called is determined\nby the variable prefix-help-command.\n Which-key: https://github.com/justbur/emacs-which-key\n makes use of this\nvariable, too. It uses the initial value as a fallback so the variable needs to\nbe set before which-key-mode is activated:\n(setq prefix-help-command #'which-key-M-x-prefix+)\n(which-key-mode 1)\nThe code of this post makes use of internal\n which-key: https://github.com/justbur/emacs-which-key\n functions and is tightly\nrelated to it, so I will keep the which-key- prefix and add a + suffix. This\napproach is what I’m using for all my personal package extensions. Using the\nsame \"name space\" has some nice benefits for search and completion and the\nunusual suffix avoids potential name clashes.\n(defun which-key-M-x-prefix+ (&optional _)\n  \"Completing read and execute command from prefix-map.\nThis command can be used as `prefix-help-command'. The optional\nargument is ignored and only for compatability with\n`which-key-C-h-dispatch' so this command can be bound in\n`which-key-C-h-map', too.\"\n  (interactive)\n  (let* ((evs (cond ((which-key--current-prefix)\n                     (which-key--current-key-list))\n                    (t\n                     (butlast (append (this-command-keys-vector) nil)))))\n         (key  (and evs (apply #'vector evs))))\n    (which-key-M-x+ key)))\n(defun which-key-M-x+ (&optional key)\n  \"Completing read command and execute it.\nOnly commands which are bound to keys are considered. If KEY is\ngiven it should be the prefix-key for which commands should be\ncompleted. Otherwise read command from top-level. \"\n  (interactive)\n  (let ((cmd (which-key--completing-read-cmd+ key)))\n    (when (commandp cmd)\n      (which-key--execute-cmd+ cmd))))\n(defun which-key--completing-read-cmd+ (&optional prefix)\n  \"Completing read command for PREFIX.\nRead commands for PREFIX or top-level if PREFIX not given.\"\n  (which-key--hide-popup-ignore-command)\n  (let ((desc\n         (completing-read\n          (if prefix\n              (format \"Execute (%s): \" (key-description prefix))\n            \"Execute: \")\n          (mapcar #'which-key--completing-read-format+\n                  (which-key--get-current-bindings prefix)))))\n    (intern (car (split-string desc)))))\n(defun which-key--execute-cmd+ (cmd)\n  \"Execute command CMD as if invoked by key sequence.\"\n  (setq prefix-arg current-prefix-arg)\n  (setq this-command cmd)\n  (setq real-this-command cmd)\n  (command-execute cmd 'record))\n(defun which-key--completing-read-format+ (bnd)\n  \"Format binding BND for `completing-read'.\"\n  (let* ((key (car bnd))\n         (cmd (cdr bnd))\n         (desc (format \"%s (%s)\" cmd\n                       (propertize key 'face 'which-key-key-face))))\n    (which-key--maybe-add-docstring\n     (format \"%-50s\" desc) cmd)))\nAfter adding the above code to your Emacs, you should be able to press a prefix\nkey and invoke the command completion with <kbd>C-h</kbd>. If the\n which-key: https://github.com/justbur/emacs-which-key\n popup is already showing\nyou need to press it twice, because it uses <kbd>C-h</kbd> for its own paging\ncommands, too. You can also complete commands from top-level by calling the\nwhich-key-M-x+ command.", "shortDescription": "As a reader of this blog you probably know about\n which-key: https://github.com/justbur/emacs-which-key\n. It is a great ...", "isRead": false}, {"title": "Show matching lines when parentheses go off-screen", "link": "https://www.with-emacs.com/posts/ui-hacks/show-matching-lines-when-parentheses-go-off-screen/", "time": "Mon, 20 May 2019 13:09:21 GMT", "author": "clemera", "description": "This posts will describe how I display lines matching off-screen parentheses at\nthe top of the window:\nThe variable blink-matching-paren can be used to configure the display of\nmatching parentheses. If you look at the source, you will see that\nblink-paren-post-self-insert-function is added to post-self-insert-hook to\ndo the job.\nThere are two things I would like to change about the way it works:\n<ol class=\"arabic\">\n1. \nWhen the matching paren goes off-screen, I usually look at the top of the\nwindow. Thus, this is the place where I would like to display the match\ninformation.\n2. \nThe matching information should be displayed after movement commands as well.\nFirst let’s take care of blink-matching-paren:\n;; we will call `blink-matching-open` ourselves...\n(remove-hook 'post-self-insert-hook\n             #'blink-paren-post-self-insert-function)\n;; this still needs to be set for `blink-matching-open` to work\n(setq blink-matching-paren 'show)\nAs I already use show-paren-mode to visualize matching parentheses it makes\nsense to look for a way to hook into it. Because of that I decided to advice\nshow-paren-function:\n(let ((ov nil)) ; keep track of the overlay\n  (advice-add\n   #'show-paren-function\n   :after\n    (defun show-paren--off-screen+ (&rest _args)\n      \"Display matching line for off-screen paren.\"\n      (when (overlayp ov)\n        (delete-overlay ov))\n      ;; check if it's appropriate to show match info,\n      ;; see `blink-paren-post-self-insert-function'\n      (when (and (overlay-buffer show-paren--overlay)\n                 (not (or cursor-in-echo-area\n                          executing-kbd-macro\n                          noninteractive\n                          (minibufferp)\n                          this-command))\n                 (and (not (bobp))\n                      (memq (char-syntax (char-before)) '(?\\) ?\\$)))\n                 (= 1 (logand 1 (- (point)\n                                   (save-excursion\n                                     (forward-char -1)\n                                     (skip-syntax-backward \"/\\\\\")\n                                     (point))))))\n        ;; rebind `minibuffer-message' called by\n        ;; `blink-matching-open' to handle the overlay display\n        (cl-letf (((symbol-function #'minibuffer-message)\n                   (lambda (msg &rest args)\n                     (let ((msg (apply #'format-message msg args)))\n                       (setq ov (display-line-overlay+\n                                 (window-start) msg ))))))\n          (blink-matching-open))))))\nTo create the overlay I have written the following helper function:\n(defun display-line-overlay+ (pos str &optional face)\n  \"Display line at POS as STR with FACE.\nFACE defaults to inheriting from default and highlight.\"\n  (let ((ol (save-excursion\n              (goto-char pos)\n              (make-overlay (line-beginning-position)\n                            (line-end-position)))))\n    (overlay-put ol 'display str)\n    (overlay-put ol 'face\n                 (or face '(:inherit default :inherit highlight)))\n    ol))\nAll that is left is to activate show-paren-mode with the settings you like:\n(setq show-paren-style 'paren\n      show-paren-delay 0.03\n      show-paren-highlight-openparen t\n      show-paren-when-point-inside-paren nil\n      show-paren-when-point-in-periphery t)\n(show-paren-mode 1)\nTo use the code of this post make sure to evaluate the code with\n lexical-scope: https://nullprogram.com/blog/2017/01/30/#1-use-lexical-scope\n.", "shortDescription": "This posts will describe how I display lines matching off-screen parentheses at\nthe top of the window:\nThe variable blin...", "isRead": false}, {"title": "Execute commands like Marty McFly", "link": "https://www.with-emacs.com/posts/ui-hacks/execute-commands-like-marty-mcfly/", "time": "Sat, 30 Mar 2019 18:13:24 GMT", "author": "clemera", "description": "Inspired by Cameron Desautels’s\n post: https://engineering.collbox.co/post/working-faster-in-emacs-by-reading-the-future/\nand\n this: https://reddit.com/r/emacs/comments/b78e6u/tips_ivy_search_thing_at_point_with_swiper/\ndiscussion on  /r/emacs: https://reddit.com/r/emacs/\n I thought about ways to\nautomate \"reading the future\". For some commands I would like to see the\ndefault value right away.\nCommands like switch-to-buffer already include it in their prompt, but can\nwe peek into the future for those which don’t? — Just kidding, of course we\ncan: this is Emacs!\n(defvar mcfly-commands\n  '(query-replace-regexp\n    flush-lines\n    keep-lines))\n(defvar mcfly-back-commands\n  '(self-insert-command\n    ivy-yank-char\n    ivy-yank-word\n    ivy-yank-symbol))\n(defun mcfly-back-to-present ()\n  (remove-hook 'pre-command-hook 'mcfly-back-to-present t)\n  (cond ((and (memq last-command mcfly-commands)\n              (equal (this-command-keys-vector) (kbd \"M-p\")))\n         ;; repeat one time to get straight to the first history item\n         (setq unread-command-events\n               (append unread-command-events\n                       (listify-key-sequence (kbd \"M-p\")))))\n        ((memq this-command mcfly-back-commands)\n         (delete-region (point)\n                        (point-max)))))\n(defun mcfly-time-travel ()\n  (when (memq this-command mcfly-commands)\n    (let* ((kbd (kbd \"M-n\"))\n           (cmd (key-binding kbd))\n           (future (and cmd\n                        (with-temp-buffer\n                          (when (ignore-errors\n                                  (call-interactively cmd) t)\n                            (buffer-string))))))\n      (when future\n        (save-excursion\n          (insert (propertize future 'face 'shadow)))\n        (add-hook 'pre-command-hook 'mcfly-back-to-present nil t)))))\n;; setup code\n(add-hook 'minibuffer-setup-hook #'mcfly-time-travel)\n(with-eval-after-load 'ivy\n  (push (cons 'swiper 'mcfly-swiper)\n        ivy-hooks-alist)\n  (defun mcfly-swiper ()\n    (let ((sym (with-ivy-window\n                 (thing-at-point 'symbol))))\n      (when sym\n        (add-hook 'pre-command-hook 'mcfly-back-to-present nil t)\n        (save-excursion\n          (insert (propertize sym 'face 'shadow)))))))\nFor commands added to the mcfly-commands variable the default value will be\nshown in the minibuffer and you can accept it with <kbd>RET</kbd>. When you start\ntyping the preview is removed automatically. There are probably some edge\ncases where the above hack fails, so feel free to submit improvements\n here: https://github.com/with-emacs/mcfly\n.\nI updated the code with an example how to achieve something similar for\nswiper. A similar method could be used for any command using ivy:\n(with-eval-after-load 'ivy\n  (push (cons 'swiper 'mcfly-swiper)\n        ivy-hooks-alist)\n  (defun mcfly-swiper ()\n    (let ((sym (with-ivy-window\n                 (thing-at-point 'symbol))))\n      (when sym\n        (add-hook 'pre-command-hook 'mcfly-back-to-present nil t)\n        (save-excursion\n          (insert (propertize sym 'face 'shadow)))))))", "shortDescription": "Inspired by Cameron Desautels’s\n post: https://engineering.collbox.co/post/working-faster-in-emacs-by-reading-the-future...", "isRead": false}, {"title": "Catch flyspell errors using frog-menus", "link": "https://www.with-emacs.com/posts/packages/catch-flyspell-errors-using-frog-menus/", "time": "Wed, 13 Mar 2019 09:57:13 GMT", "author": "clemera", "description": "The regular Emacs way of prompting the user for input is either through the\nminibuffer or with a dedicated popup window. The former is often too far\naway from my current focus and the latter always felt a bit intrusive to me.\nAs with multi line minibuffer prompts, popup windows tend to disturb the\nwindow setup and are particular annoying when the current cursor position is\nin the way (which causes the buffer to get bumped around).\nEmacs 26 introduced a new feature called\n child-frames: https://www.gnu.org/software/emacs/manual/html_node/elisp/Child-Frames.html#Child-Frames\nwhich provides an alternate way to prompt the user or display information.\nThere are already many packages bringing this feature to some of the most\npopular extensions like  eldoc-box: https://github.com/casouri/eldoc-box\n,\n flycheck: https://github.com/alexmurray/flycheck-posframe\n,\n ivy: https://github.com/tumashu/ivy-posframe\n,\n helm: https://github.com/tumashu/helm-posframe\n and\n company: https://github.com/tumashu/company-posframe\n.\nInspired by  ace-popup-menu: https://github.com/mrkkrp/ace-popup-menu\n I created\na new package which allows you to create a so called\n frog-menu: https://github.com/clemera/frog-menu\n using a\n posframe: https://github.com/tumashu/posframe\n:\nIf you live in the terminal you can use it, too:\nIn the latter case you might also be happy using\n ace-popup-menu: https://github.com/mrkkrp/ace-popup-menu\n although one\nadvantage with frog-menu is that the action keys on the bottom are static\nbecause they are bound to key chords and not chosen by avy key hints.\nCreating a frog-menu is pretty easy:\n(frog-menu-read \"What theme?\"\n                (mapcar #'symbol-name (custom-available-themes)))\nTo chose one of the suggestions you simply press the highlighted key. For more\ninformation see the project  README: https://github.com/clemera/frog-menu\n. If\nyou are interested, please give it a try and report any issues you might have.\nHopefully there aren’t many of them so I can publish the package to\n GNU ELPA: https://elpa.gnu.org/packages/\n soon.", "shortDescription": "The regular Emacs way of prompting the user for input is either through the\nminibuffer or with a dedicated popup window....", "isRead": false}, {"title": "Objed spotlight: Move to first or last instance", "link": "https://www.with-emacs.com/posts/objed/spotlight-objed-move-to-first-or-last-instance/", "time": "Sun, 27 Jan 2019 17:38:06 GMT", "author": "clemera", "description": "I got asked to write a tutorial for  objed: https://github.com/clemera/objed\n,\nsimilar to the built-in help-with-tutorial. The main reason I haven’t done\nthis yet, is that key bindings and behavior still change from time to time. I\nplan to write such a tutorial a soon as objed reaches 1.0. In the meantime I\nwant to publish a couple of posts, for the early adopters and maybe other\ncurious people. Each of these posts will be a short description of one\nspecific feature.\nThis post assumes that you already understand the basic concepts of objed. If\nthat’s not the case please read the\n introduction: https://github.com/clemera/objed#introduction\n first.\nAs the title suggests this post is about moving to the first or last instance\nof an object. In recent versions you can do this using <kbd><</kbd> or <kbd>></kbd>\nrespectively.\nThe simplest use case is to move to the first or last line of the current\nbuffer. When the line object is active, <kbd><</kbd> or <kbd>></kbd> will take you to\nthe first or last non-empty line. For buffers containing Emacs Lisp code I\noften find it useful to jump to the first line of the actual code and skip any\npossible headers and comments. One way to do this with objed, is by switching\nto the defun object, for example by pressing <kbd>c d</kbd> and jump to the first\none using <kbd><</kbd>.\nAnother use case is to jump to the definition of a function or some variable.\nAfter you have chosen the identifier object using <kbd>.</kbd>, <kbd><</kbd> will take\nyou to the first occurrence of this symbol, which usually is the definition.\nIf you ever want to go back to some place you where before, use <kbd>u</kbd>. It\nlets you pop to previous objects from the history stack.\nThat’s it for the current  spotlight: https://with-emacs.com/tags/objed-spotlight/\n, I\nhope you got something out of it.", "shortDescription": "I got asked to write a tutorial for  objed: https://github.com/clemera/objed\n,\nsimilar to the built-in help-with-tutoria...", "isRead": false}]}, {"feed_link": "https://www.oschina.net/news/rss", "feed_title": "OSCHINA 社区最新新闻", "feed_subtitle": "OSCHINA - 中文开源技术交流社区", "feed_article_list": [{"title": "Firefox 跟上 Chrome 步伐，将默认阻止不安全的下载", "link": "https://www.oschina.net/news/155362/firefox-will-block-insecure-downloads", "time": "Sat, 14 Aug 2021 09:03:43 +0800", "author": "", "description": "Mozilla 近日透露，他们将在 Firefox 浏览器上引入一个新功能，这个功能将阻止用户在混合内容环境中下载不安全的文件。 混合内容指的是一个同时使用了安全连接和不安全连接的网站。想象一下以下情况：用户访问了一个使用 HTTPS 的安全网站，通过点击链接开始下载所需的内容。但链接指向的资源本身并没有采用 HTTPS，而是...", "shortDescription": "Mozilla 近日透露，他们将在 Firefox 浏览器上引入一个新功能，这个功能将阻止用户在混合内容环境中下载不安全的文件。 混合内容指的是一个同时使用了安全连接和不安全连接的网站。想象一下以下情况：用户访问了一个使用 HTTPS 的安...", "isRead": false}, {"title": "网易数帆开源 API 网关与容器云项目，让云原生生产落地“多快好省”", "link": "https://www.oschina.net/news/155361", "time": "Sat, 14 Aug 2021 08:22:13 +0800", "author": "", "description": "继年初开源服务网格智能管理器Slime之后，网易数帆近日宣布，正式开源旗下基于Envoy/Istio的云原生API网关项目Hango（函谷），和可视化多租户Kubernetes管理平台KubeCube，为云原生开源生态注入高性能、强兼容、易用性等众多能力，屏蔽分布式架构底层的复杂性，推动云原生生产落地。 Hango：性能提升2倍，全面整合云原生...", "shortDescription": "继年初开源服务网格智能管理器Slime之后，网易数帆近日宣布，正式开源旗下基于Envoy/Istio的云原生API网关项目Hango（函谷），和可视化多租户Kubernetes管理平台KubeCube，为云原生开源生态注入高性能、强兼容、易...", "isRead": false}, {"title": "Gartner：2022 年全球公有云支出将超 4800 亿美元", "link": "https://www.oschina.net/news/155360/gartner-public-cloud-trends", "time": "Sat, 14 Aug 2021 08:17:45 +0800", "author": "", "description": "Gartner 在一份报告中预测称，公有云行业将在未来几年内实现大规模增长。预计在 2021 年，用户在公共云服务上的支出将达到 3960 亿美元；并在 2022 年增长 21.7%，达到 4820 亿美元。此外，预测到 2026 年，公共云支出将超过所有企业 IT 支出的 45%（2021 年的占比约为 17%）。 云计算的四大新趋势正在继续扩大云产品和功...", "shortDescription": "Gartner 在一份报告中预测称，公有云行业将在未来几年内实现大规模增长。预计在 2021 年，用户在公共云服务上的支出将达到 3960 亿美元；并在 2022 年增长 21.7%，达到 4820 亿美元。此外，预测到 2026 年，公共...", "isRead": false}, {"title": "游戏引擎 Unity 将支持开源机器人中间件 ROS 2", "link": "https://www.oschina.net/news/155359/unity-announces-support-for-ros-2", "time": "Sat, 14 Aug 2021 08:17:34 +0800", "author": "", "description": "Unity 是全球领先的实时 3D（RT3D）内容的创建和操作平台，继今年早些时候 Unity 宣布支持 ROS 1 之后，近日 Unity 宣布将支持 ROS 2 —— 这是一个来自 Open Robotics 的开源机器人中间件套件。 ROS 是一个用于在不同进程间匿名的发布、订阅、传递信息的中间件。 ROS 1 构建于 Linux 系统之上，主要支持 Ubuntu。而 RO...", "shortDescription": "Unity 是全球领先的实时 3D（RT3D）内容的创建和操作平台，继今年早些时候 Unity 宣布支持 ROS 1 之后，近日 Unity 宣布将支持 ROS 2 —— 这是一个来自 Open Robotics 的开源机器人中间件套件。 ...", "isRead": false}, {"title": "Sampler —— 命令行下的可视化展示工具", "link": "https://www.oschina.net/p/sampler", "time": "Sat, 14 Aug 2021 08:05:02 +0800", "author": "", "description": "Sampler 是一个用于在命令行环境下进行命令执行、可视化展示和警告的工具，使用 YAML 配置文件。", "shortDescription": "Sampler 是一个用于在命令行环境下进行命令执行、可视化展示和警告的工具，使用 YAML 配置文件。", "isRead": false}, {"title": "Gitee 推荐 | 面向机器学习应用的数据库 OpenMLDB", "link": "https://gitee.com/paradigm4/OpenMLDB", "time": "Sat, 14 Aug 2021 08:02:33 +0800", "author": "", "description": "OpenMLDB是一个面向机器学习应用提供正确、高效数据供给的开源数据库。除了超过10倍的机器学习数据开发效率的提升，OpenMLDB也提供了统一的计算与存储引擎减少开发运维的复杂性与总体成本。", "shortDescription": "OpenMLDB是一个面向机器学习应用提供正确、高效数据供给的开源数据库。除了超过10倍的机器学习数据开发效率的提升，OpenMLDB也提供了统一的计算与存储引擎减少开发运维的复杂性与总体成本。", "isRead": false}, {"title": "每日一博 | 京东 app 后台多端融合架构代码重构实战", "link": "https://my.oschina.net/1Gk2fdm43/blog/5180537", "time": "Sat, 14 Aug 2021 08:01:10 +0800", "author": "", "description": "重构是一个非常常见且古老的课题，涉及重构的文章、书更是不可胜数。", "shortDescription": "重构是一个非常常见且古老的课题，涉及重构的文章、书更是不可胜数。", "isRead": false}, {"title": "TypeScript 4.4 RC 发布", "link": "https://www.oschina.net/news/155350/typescript-4-4-rc-released", "time": "Sat, 14 Aug 2021 07:33:59 +0800", "author": "", "description": "TypeScript 4.4 RC 现已发布。官方表示，从现在开始到 TypeScript 4.4 的稳定发布，预计除了关键的 bug 修复外，不会再有更多的变化。 可通过 NuGet 或以下 npm 进行获取： \nnpm install typescript@rc 下面是 IDE 或编辑器获取 TypeScript 支持的途径： 下载 Visual Studio 2019/2017 尝试 Visual Studio Code Insider...", "shortDescription": "TypeScript 4.4 RC 现已发布。官方表示，从现在开始到 TypeScript 4.4 的稳定发布，预计除了关键的 bug 修复外，不会再有更多的变化。 可通过 NuGet 或以下 npm 进行获取： \nnpm install ...", "isRead": false}, {"title": "Thunderbird 91.0 正式发布，原生支持 M1，默认使用多进程", "link": "https://www.oschina.net/news/155346/thunderbird-91-0-released", "time": "Sat, 14 Aug 2021 07:00:38 +0800", "author": "", "description": "Thunderbird 91.0 版只能从 thunderbird.net 下载并安装，不能从 Thunderbird 78 或更早的版本直接升级至 91 版本。 系统要求 Windows：Windows 7 或更高版本； macOS：macOS 10.12 或更高版本； Linux：GTK+ 3.14 或更高版本； 新增 原生支持使用了 Apple Silicon CPU 的 macOS 设备； Thunderbird 现在默认在多进程（e...", "shortDescription": "Thunderbird 91.0 版只能从 thunderbird.net 下载并安装，不能从 Thunderbird 78 或更早的版本直接升级至 91 版本。 系统要求 Windows：Windows 7 或更高版本； macOS：ma...", "isRead": false}, {"title": "DataPipeline 正式加入 openGauss 社区", "link": "https://www.oschina.net/news/155300", "time": "Fri, 13 Aug 2021 18:39:20 +0800", "author": "", "description": "2021 年 8 月，DataPipeline 数见科技与 GaussDB(for openGauss) 完成兼容性测试，并且签署 CLA(Contribution License Agreement, 贡献许可协议），正式加入 openGauss 社区。 DataPipeline 数见科技是一家企业级批流一体数据融合产品、解决方案及服务提供商，通过多种实时数据技术协助用户构建起数据全面准确、管理敏捷...", "shortDescription": "2021 年 8 月，DataPipeline 数见科技与 GaussDB(for openGauss) 完成兼容性测试，并且签署 CLA(Contribution License Agreement, 贡献许可协议），正式加入 openG...", "isRead": false}, {"title": "OpenYurt 联手 eKuiper，解决 IoT 场景下边缘流数据处理难题", "link": "https://www.oschina.net/news/155247", "time": "Fri, 13 Aug 2021 14:38:39 +0800", "author": "", "description": "云计算的出现促使物联网实现爆炸式增长。在设备规模和业务复杂度不断攀升的趋势之下，边缘计算因其能够将计算能力更靠近网络边缘和设备，从而带来云性能成本的降低，也在这波浪潮之下得到快速发展。 诚然，物联网边缘计算尚处发展初期，有许多挑战需要被解决。比如在大量软件及通信协议极为复杂的设备异构环境下，需要具...", "shortDescription": "云计算的出现促使物联网实现爆炸式增长。在设备规模和业务复杂度不断攀升的趋势之下，边缘计算因其能够将计算能力更靠近网络边缘和设备，从而带来云性能成本的降低，也在这波浪潮之下得到快速发展。 诚然，物联网边缘计算尚处发展初期，有许多挑战需要被解决...", "isRead": false}, {"title": "RT-Thread Studio V2.1.1 新版本发布啦！", "link": "https://www.oschina.net/news/155243", "time": "Fri, 13 Aug 2021 14:31:16 +0800", "author": "", "description": "二十四节气的大暑已悄然而过，气温日渐攀升，窗外灿烂的阳光下，响起此起彼伏清脆的知鸟声，仿佛在向大家宣告，盛夏来临啦！此时东京奥运会上的的奥运健儿们正在赛场上向着更高，更快，更强的目标拼搏着，RT-Thread Studio V2.1.1 新版本也已就绪，准备和大家见面了! 本次发布主要更新和上线了一些SDK资源包，其中包括重...", "shortDescription": "二十四节气的大暑已悄然而过，气温日渐攀升，窗外灿烂的阳光下，响起此起彼伏清脆的知鸟声，仿佛在向大家宣告，盛夏来临啦！此时东京奥运会上的的奥运健儿们正在赛场上向着更高，更快，更强的目标拼搏着，RT-Thread Studio V2.1.1 新...", "isRead": false}, {"title": "新唐科技 (Nuvoton) 正式成为 RT-Thread 高级会员", "link": "https://www.oschina.net/news/155242", "time": "Fri, 13 Aug 2021 14:29:16 +0800", "author": "", "description": "微控制器领导厂商新唐科技（Nuvoton）与知名物联网操作系统厂商睿赛德科技（RT-Thread）签署会员合作协议，新唐科技正式成为RT-Thread高级会员。双方将携手深度合作、充分发挥各自优势，为开发者和终端客户提供更加丰富的、灵活的软硬件开发生态系统和产品组合选择，加速产品开发效率，共筑物联网产业生态发展。 中美贸易...", "shortDescription": "微控制器领导厂商新唐科技（Nuvoton）与知名物联网操作系统厂商睿赛德科技（RT-Thread）签署会员合作协议，新唐科技正式成为RT-Thread高级会员。双方将携手深度合作、充分发挥各自优势，为开发者和终端客户提供更加丰富的、灵活的软...", "isRead": false}, {"title": "JNI 中错误的信号处理导致 JVM 崩溃问题分析", "link": "https://my.oschina.net/openeuler/blog/5176487", "time": "Fri, 13 Aug 2021 10:55:25 +0800", "author": "", "description": "本文分析 Cassandra 使用 JNI 本地库导致 JVM 崩溃的一个案例，最后定位问题根源是信号的错误处理（一些 C 编程人员经常会截获信号，做一些额外的处理），该案例提示 JNI 编程时不要随意截获信号处理。", "shortDescription": "本文分析 Cassandra 使用 JNI 本地库导致 JVM 崩溃的一个案例，最后定位问题根源是信号的错误处理（一些 C 编程人员经常会截获信号，做一些额外的处理），该案例提示 JNI 编程时不要随意截获信号处理。", "isRead": false}, {"title": "eBPF 基金会正式成立，微软、Google、Facebook、Netflix 和 Isovalent 成为创始成员", "link": "https://www.oschina.net/news/155180/ebpf-foundation", "time": "Fri, 13 Aug 2021 08:35:52 +0800", "author": "", "description": "eBPF 是一种可以在操作系统内核中运行沙盒程序的技术。eBPF 使我们能够安全地扩展内核的功能，而不需要改变内核的源代码或加载内核模块。 虽然 eBPF 从 2014 年诞生起就是为 Linux 内核而设计的，但今年 5 月，微软宣布了一个 eBPF for Windows 的新项目，使 eBPF 还能够在 Windows 10 和 Windows Server 2016 及以后的版...", "shortDescription": "eBPF 是一种可以在操作系统内核中运行沙盒程序的技术。eBPF 使我们能够安全地扩展内核的功能，而不需要改变内核的源代码或加载内核模块。 虽然 eBPF 从 2014 年诞生起就是为 Linux 内核而设计的，但今年 5 月，微软宣布了一...", "isRead": false}, {"title": "Google 开源 Allstar ，为 GitHub 项目持续实施最佳安全实践", "link": "https://www.oschina.net/news/155179/google-open-source-allstar", "time": "Fri, 13 Aug 2021 08:33:20 +0800", "author": "", "description": "如今，安全漏洞日益困扰着大型开源项目。根据 RiskSense 的统计数据，与 2018 年相比，2019 年开源软件漏洞的数量增加了一倍多。考虑到近 91% 的商业应用程序包含过时或废弃的开源组件，因此安全漏洞的影响是深远的。 作为开源软件社区的一员，Google 非常清楚软件供应链攻击对开源项目构成的威胁日益严重，而 Allstar ...", "shortDescription": "如今，安全漏洞日益困扰着大型开源项目。根据 RiskSense 的统计数据，与 2018 年相比，2019 年开源软件漏洞的数量增加了一倍多。考虑到近 91% 的商业应用程序包含过时或废弃的开源组件，因此安全漏洞的影响是深远的。 作为开源软...", "isRead": false}, {"title": "Redis Labs 更名为 Redis：纯粹而简单", "link": "https://www.oschina.net/news/155178/redis-labs-becomes-simply-redis", "time": "Fri, 13 Aug 2021 08:27:15 +0800", "author": "", "description": "Redis Labs 方面宣布，该公司现已正式更名为 Redis，从名称中删除了“Labs”一词。 官方表示，这一变化标志着公司和 Redis 开源项目的成熟；也反映了公司继续将 Redis 作为实时数据平台发展的使命。“更名反映了公司在引领开源 Redis 从流行的缓存系统演变为领先的实时数据平台方面所保持的核心作用”。公司更名不会影响...", "shortDescription": "Redis Labs 方面宣布，该公司现已正式更名为 Redis，从名称中删除了“Labs”一词。 官方表示，这一变化标志着公司和 Redis 开源项目的成熟；也反映了公司继续将 Redis 作为实时数据平台发展的使命。“更名反映了公司在引...", "isRead": false}, {"title": "Linux Kernel 为支持 AV1 解码做准备", "link": "https://www.oschina.net/news/155177/linux-media-rfc-av1-uapi", "time": "Fri, 13 Aug 2021 08:26:23 +0800", "author": "", "description": "目前市场上提供加速 AV1 编码的硬件平台数量仍然非常有限，但随着更多支持这种免版税视频编解码器编码/解码的硬件上市，Linux 内核的媒体子系统也正在准备就绪。 本周二，来自 Collabora 公司的 Daniel Almeida 发出了一个\"request for comments\"(RFC)系列补丁，用于在媒体子系统中为 Linux 内核实现无状态 AV1 user-spa...", "shortDescription": "目前市场上提供加速 AV1 编码的硬件平台数量仍然非常有限，但随着更多支持这种免版税视频编解码器编码/解码的硬件上市，Linux 内核的媒体子系统也正在准备就绪。 本周二，来自 Collabora 公司的 Daniel Almeida 发出...", "isRead": false}, {"title": "高手问答 265 期 —— 学 Python，如何学更高效？", "link": "https://www.oschina.net/question/4252687_2323484", "time": "Fri, 13 Aug 2021 08:15:43 +0800", "author": "", "description": "Python 这么火，Python 办公自动化是吸引职场人学习的动力，你们都用 Python 实现了哪些办公自动化？都用到了那些好玩有趣的库？效果怎么样？你们认为什么样的工作适合用 Python 来实现办公自动化？欢迎来一起探讨。", "shortDescription": "Python 这么火，Python 办公自动化是吸引职场人学习的动力，你们都用 Python 实现了哪些办公自动化？都用到了那些好玩有趣的库？效果怎么样？你们认为什么样的工作适合用 Python 来实现办公自动化？欢迎来一起探讨。", "isRead": false}, {"title": "每日一博 | Docker 卷到底是个啥玩意？从使用到深入！", "link": "https://my.oschina.net/u/4579512/blog/4694199", "time": "Fri, 13 Aug 2021 08:04:00 +0800", "author": "", "description": "Docker 支持持久化和非持久化两种方式的存储。 非持久化化存储自动创建，从属于容器，生命周期与容器相同，即删除容器也会删除全部非持久化数据。 如果想把容器中的数据保留下来，也就是持久化，那么需要将数据存储到卷上。卷与容器是解耦的，从而可以独立地创建并管理卷，并且卷也不与任意容器声明周期绑定，即用户删除...", "shortDescription": "Docker 支持持久化和非持久化两种方式的存储。 非持久化化存储自动创建，从属于容器，生命周期与容器相同，即删除容器也会删除全部非持久化数据。 如果想把容器中的数据保留下来，也就是持久化，那么需要将数据存储到卷上。卷与容器是解耦的，从而可...", "isRead": false}, {"title": "Airyx —— 基于 FreeBSD 的开源操作系统", "link": "https://www.oschina.net/p/airyx", "time": "Fri, 13 Aug 2021 08:03:17 +0800", "author": "", "description": "Airyx 是一个新的开源桌面操作系统，旨在为 x86-64 系统提供与 macOS 相似的体验和兼容性。它建立在 FreeBSD 的坚实基础上，Airyx 的目标是给人以平滑、稳定、熟悉和直观的感觉，处理你的日常任务，并尽可能地提供与激发它的商业操作系统的兼容性。", "shortDescription": "Airyx 是一个新的开源桌面操作系统，旨在为 x86-64 系统提供与 macOS 相似的体验和兼容性。它建立在 FreeBSD 的坚实基础上，Airyx 的目标是给人以平滑、稳定、熟悉和直观的感觉，处理你的日常任务，并尽可能地提供与激发...", "isRead": false}, {"title": "Gitee 推荐 | 开源的游戏客户端与服务端框架 ET", "link": "https://gitee.com/yuxusheng/ET", "time": "Fri, 13 Aug 2021 08:02:26 +0800", "author": "", "description": "ET 是一个开源的游戏客户端（基于 Unity 3D）服务端双端框架，服务端是使用 C# .net core 开发的分布式游戏服务端，其特点是开发效率高，性能强，双端共享逻辑代码，客户端服务端热更机制完善。", "shortDescription": "ET 是一个开源的游戏客户端（基于 Unity 3D）服务端双端框架，服务端是使用 C# .net core 开发的分布式游戏服务端，其特点是开发效率高，性能强，双端共享逻辑代码，客户端服务端热更机制完善。", "isRead": false}, {"title": "Visual Studio 2022 Preview 3 发布", "link": "https://www.oschina.net/news/155169/visual-studio-2022-preview-3-released", "time": "Fri, 13 Aug 2021 07:40:17 +0800", "author": "", "description": "Visual Studio 2022 Preview 3 现已推出，该版本提供了更多有关于个人和团队生产力、现代开发和不断创新为主题的新功能。 下载地址：https://aka.ms/vs2022preview 个人和团队生产力 在 Preview 3 中，开发团队为一些不太常用但很有用的功能添加了新功能，例如附加到进程。 附加到进程改进 一个例子是对附加到进程的对话...", "shortDescription": "Visual Studio 2022 Preview 3 现已推出，该版本提供了更多有关于个人和团队生产力、现代开发和不断创新为主题的新功能。 下载地址：https://aka.ms/vs2022preview 个人和团队生产力 在 Pre...", "isRead": false}, {"title": "Shutter 0.98 发布，Linux 屏幕截图工具", "link": "https://www.oschina.net/news/155166/shutter-0-98-released", "time": "Fri, 13 Aug 2021 07:17:24 +0800", "author": "", "description": "Shutter 是一个功能丰富的屏幕截图程序，适用于基于 Linux 的操作系统。用户可以对一个特定的区域、窗口、整个屏幕，甚至是一个网站进行截图。并且可以在截图后对图片进行适当编辑，然后上传到图片托管网站，所有这些操作都能在一个窗口内完成。 Shutter 0.98 正式发布，自 0.96 版本以来修复了众多 bug： 修复： 在启动...", "shortDescription": "Shutter 是一个功能丰富的屏幕截图程序，适用于基于 Linux 的操作系统。用户可以对一个特定的区域、窗口、整个屏幕，甚至是一个网站进行截图。并且可以在截图后对图片进行适当编辑，然后上传到图片托管网站，所有这些操作都能在一个窗口内完成...", "isRead": false}, {"title": "StreamNative 正式加入“腾讯云原生加速器”，助推云原生产业高速前行", "link": "https://www.oschina.net/news/155067", "time": "Thu, 12 Aug 2021 16:33:50 +0800", "author": "", "description": "近年来，互联网创新正在迎来从消费互联网向产业互联网的转型，在数字化浪潮下，以“云原生”为技术路线，构建信息化和应用服务平台，已经成为企业搭建面向未来应用架构的首选。 为了让云原生架构得到应用和完善，进一步发挥产业互联网“生态共创”优势，国内首个云原生加速器——“腾讯云原生加速器” 应运而生。近期，腾...", "shortDescription": "近年来，互联网创新正在迎来从消费互联网向产业互联网的转型，在数字化浪潮下，以“云原生”为技术路线，构建信息化和应用服务平台，已经成为企业搭建面向未来应用架构的首选。 为了让云原生架构得到应用和完善，进一步发挥产业互联网“生态共创”优势，国内...", "isRead": false}, {"title": "北联国芯正式加入 openGauss 社区", "link": "https://www.oschina.net/news/155062", "time": "Thu, 12 Aug 2021 16:28:07 +0800", "author": "", "description": "江苏北联国芯技术有限公司（以下简称 “北联国芯”）签署 CLA ( Contribution License Agreement，贡献者许可协议），正式加入 openGauss 社区，携手共推信创行业数据库的发展。 北联国芯是南京江北新区倾力打造的 “鲲鹏 + 昇腾” 计算产业龙头企业与产业生态使能者，全面负责鲲鹏 + 昇腾计算平台系列产品的设计、生产、...", "shortDescription": "江苏北联国芯技术有限公司（以下简称 “北联国芯”）签署 CLA ( Contribution License Agreement，贡献者许可协议），正式加入 openGauss 社区，携手共推信创行业数据库的发展。 北联国芯是南京江北新区倾...", "isRead": false}, {"title": "泰凡科技正式加入 openGauss 社区", "link": "https://www.oschina.net/news/155060", "time": "Thu, 12 Aug 2021 16:22:00 +0800", "author": "", "description": "天津泰凡科技有限公司（以下简称泰凡科技）签署 CLA(Contribution License Agreement, 贡献许可协议），正式加入 openGauss 社区。 天津泰凡科技有限公司是一家提供数据智慧应用与知识管理的人工智能科创企业，在知识图谱、语义分析、智能问答、大数据分析、数字孪生、数据可视化等技术领域深耕多年，具有深厚的研发成果...", "shortDescription": "天津泰凡科技有限公司（以下简称泰凡科技）签署 CLA(Contribution License Agreement, 贡献许可协议），正式加入 openGauss 社区。 天津泰凡科技有限公司是一家提供数据智慧应用与知识管理的人工智能科创企...", "isRead": false}, {"title": "微软多个产品发布安全更新通告：包含 7 个严重漏洞、37 个高危漏洞", "link": "https://www.oschina.net/news/155053", "time": "Thu, 12 Aug 2021 16:04:35 +0800", "author": "", "description": "报告编号：B6-2021-081101 报告来源：360CERT 报告作者：360CERT 更新日期：2021-08-11 事件简述 2021年08月11日，360CERT监测发现微软发布了8月份安全更新，事件等级：严重，事件评分：9.9。 此次安全更新发布了44个漏洞的补丁，主要覆盖了以下组件：Windows操作系统、Microsoft Graphics Component、Remote Desktop Cl...", "shortDescription": "报告编号：B6-2021-081101 报告来源：360CERT 报告作者：360CERT 更新日期：2021-08-11 事件简述 2021年08月11日，360CERT监测发现微软发布了8月份安全更新，事件等级：严重，事件评分：9.9。...", "isRead": false}, {"title": "AutoK3s v0.4.4 发布，K3s 集群资源管理 so easy！", "link": "https://www.oschina.net/news/155031", "time": "Thu, 12 Aug 2021 14:36:20 +0800", "author": "", "description": "AutoK3s是一款K3s集群自动化部署工具，可以方便开发者自助管理云环境中的K3s集群，之前的版本支持了AWS/Aliyun/TencentCloud三个主流公有云，以及管理本地K3d集群。 AutoK3s可以协助开发者自助管理多云环境中的K3s集群，在最新的v0.4.4版本中，我们集成了轻量级的K8s管理工具(kube-explorer)，来提升多集群管理体验。 关...", "shortDescription": "AutoK3s是一款K3s集群自动化部署工具，可以方便开发者自助管理云环境中的K3s集群，之前的版本支持了AWS/Aliyun/TencentCloud三个主流公有云，以及管理本地K3d集群。 AutoK3s可以协助开发者自助管理多云环境中...", "isRead": false}, {"title": "Erda 1.1 版本发布｜3 大亮点特性最新解读", "link": "https://www.oschina.net/news/155014", "time": "Thu, 12 Aug 2021 13:25:43 +0800", "author": "", "description": "Erda v1.1 Changelog： https://github.com/erda-project/erda/blob/master/CHANGELOG/CHANGELOG-1.x.md Erda 是由端点开源的一站式云原生 PaaS 平台，项目自开源发布以来，吸引了众多相关领域的专家和开发者们的关注，在大家的积极反馈下，社区的开发工作发展迅速。2021 年 7 月 27 日晚，Erda 1.1 版本正式发布，主要新...", "shortDescription": "Erda v1.1 Changelog： https://github.com/erda-project/erda/blob/master/CHANGELOG/CHANGELOG-1.x.md Erda 是由端点开源的一站式云原生 PaaS...", "isRead": false}, {"title": "微众银行 AI 开源项目 - 7月进展合集", "link": "https://www.oschina.net/news/154988", "time": "Thu, 12 Aug 2021 09:44:36 +0800", "author": "", "description": "FATE 联邦学习系统 FATE V1.7整体开发进度：60% FATE-FLOW: 1. 作业自动重试功能完成 2. 组件插件化支持一个job组件多版本联调20% 3. Upload/Reader组件优化 4. 新增匹配ID列 FederatedML: 1. 完成PSI交集缓存方案开发，正在进行性能测试 2. 两方逻辑回归性能优化，3w数据下降低为原来的2/3 3. dataTransform支持匹配id，...", "shortDescription": "FATE 联邦学习系统 FATE V1.7整体开发进度：60% FATE-FLOW: 1. 作业自动重试功能完成 2. 组件插件化支持一个job组件多版本联调20% 3. Upload/Reader组件优化 4. 新增匹配ID列 Feder...", "isRead": false}, {"title": "Fes.js 微前端，轻松拿捏巨石应用新需求~", "link": "https://www.oschina.net/news/154987", "time": "Thu, 12 Aug 2021 09:43:26 +0800", "author": "", "description": "巨石应用，往往技术古老、逻辑耦合、性能较差、体验欠佳，再加上前期对系统定位不清晰，积年累月，包袱越来越重，一个很小的改动就可能牵一发而动全身，让人望而却步。而近期的开发任务都是在\"巨石应用\"上新增需求，然后就探到宝藏: Fes.js 微前端. 什么是微前端？为什么使用微前端？这些问题有很多文章都可深扒，这里就...", "shortDescription": "巨石应用，往往技术古老、逻辑耦合、性能较差、体验欠佳，再加上前期对系统定位不清晰，积年累月，包袱越来越重，一个很小的改动就可能牵一发而动全身，让人望而却步。而近期的开发任务都是在\"巨石应用\"上新增需求，然后就探到宝藏: Fes.js 微前端...", "isRead": false}, {"title": "Facebook 开源 Time Card 原子钟技术，以加速互联网服务", "link": "https://www.oschina.net/news/154980/facebook-open-source-time-appliance", "time": "Thu, 12 Aug 2021 08:54:25 +0800", "author": "", "description": "Facebook 在昨天分享了其 \"Time Cards\" 的硬件和软件设计，该设备用于保持其庞大的数据中心在最高效率下进行运转。这种基于极其精确的原子钟和导航卫星的计时技术，最终有助于加快互联网规模下运行的各种服务。 每一台计算设备都需要知道现在是什么时间，有了时间这个维度，设备才能正确提供各种服务并记录各种类型的日志...", "shortDescription": "Facebook 在昨天分享了其 \"Time Cards\" 的硬件和软件设计，该设备用于保持其庞大的数据中心在最高效率下进行运转。这种基于极其精确的原子钟和导航卫星的计时技术，最终有助于加快互联网规模下运行的各种服务。 每一台计算设备都需要...", "isRead": false}, {"title": "GitHub 工程团队的开发环境迁移至 Codespaces", "link": "https://www.oschina.net/news/154976/githubs-engineering-team-moved-codespaces", "time": "Thu, 12 Aug 2021 08:30:28 +0800", "author": "", "description": "GitHub 官方宣布，负责 github.com 的工程团队已将开发环境迁移至 Codespaces。 GitHub.com 的代码库已诞生将近 14 年。当 github.com 的第一个 commit 被推送时，Rails 只有两年的历史，AWS 才诞生一年，Azure 和 GCP 尚未问世。在这 14 年里，GitHub.com 的核心仓库 (github/github) 已收到超过一百万次 commit，其中绝...", "shortDescription": "GitHub 官方宣布，负责 github.com 的工程团队已将开发环境迁移至 Codespaces。 GitHub.com 的代码库已诞生将近 14 年。当 github.com 的第一个 commit 被推送时，Rails 只有两年的...", "isRead": false}, {"title": "OpenAI 开启 Codex 测试，一个将自然语言翻译成代码的 AI 系统", "link": "https://www.oschina.net/news/154975/openai-codex-translates-plain-english-into-code", "time": "Thu, 12 Aug 2021 08:27:44 +0800", "author": "", "description": "人工智能创业公司 OpenAI 在得到了微软等公司的大力支持后，如今推出新产品的速度也越来越快。继去年的 GTP-3 之后，如今时隔一年 OpenAI 宣布将通过 API 向企业和开发者提供访问其 Codex 程序的机会。 OpenAI Codex 是一个利用人工智能系统将自然语言翻译成代码的程序。Codex 能够理解十几种编程语言，开发者可以用自然...", "shortDescription": "人工智能创业公司 OpenAI 在得到了微软等公司的大力支持后，如今推出新产品的速度也越来越快。继去年的 GTP-3 之后，如今时隔一年 OpenAI 宣布将通过 API 向企业和开发者提供访问其 Codex 程序的机会。 OpenAI C...", "isRead": false}, {"title": "AI 市场有望在 2024 年突破 5000 亿美元大关", "link": "https://www.oschina.net/news/154973/idc-ai-predict", "time": "Thu, 12 Aug 2021 08:21:40 +0800", "author": "", "description": "国际数据公司 IDC 最新发布的一份全球半年度人工智能（AI）跟踪报告指出，包括软件、硬件和服务在内的全球人工智能（AI）市场预计将在 2021 年同比增长 15.2%，达到 3418 亿美元。预计 2022 年市场还将进一步加速，增长 18.8%；到 2024 年仍有望突破 5000 亿美元大关。 在三个技术类别中，AI 软件占据了整个 AI 市场的 ...", "shortDescription": "国际数据公司 IDC 最新发布的一份全球半年度人工智能（AI）跟踪报告指出，包括软件、硬件和服务在内的全球人工智能（AI）市场预计将在 2021 年同比增长 15.2%，达到 3418 亿美元。预计 2022 年市场还将进一步加速，增长 1...", "isRead": false}, {"title": "Pulumi —— 架构即是代码", "link": "https://www.oschina.net/p/pulumi", "time": "Thu, 12 Aug 2021 08:12:53 +0800", "author": "", "description": "Pulumi 是一个架构即是代码的开源项目，可在任何云上创建和部署使用容器，无服务器功能，托管服务和基础架构的云软件的最简单方法。", "shortDescription": "Pulumi 是一个架构即是代码的开源项目，可在任何云上创建和部署使用容器，无服务器功能，托管服务和基础架构的云软件的最简单方法。", "isRead": false}, {"title": "Gitee 推荐 | App 版本更新和公告发布管理平台 AJ-Appsp", "link": "https://gitee.com/anji-plus/appsp", "time": "Thu, 12 Aug 2021 08:07:21 +0800", "author": "", "description": "完全开源，提供专业App版本更新和版本管理解决方案，支持灰度发布，界面简洁优雅易用，可以和小伙伴一块维护版本，我们提供Android、IOS、Flutter的SDK集成示例。提供管理后台的前后端源码，帮您快速构建企业内App版本升级和公告功能。", "shortDescription": "完全开源，提供专业App版本更新和版本管理解决方案，支持灰度发布，界面简洁优雅易用，可以和小伙伴一块维护版本，我们提供Android、IOS、Flutter的SDK集成示例。提供管理后台的前后端源码，帮您快速构建企业内App版本升级和公告功...", "isRead": false}, {"title": "每日一博 | 构建数据湖上低延迟数据 Pipeline 的实践", "link": "https://my.oschina.net/dailidong/blog/4704092", "time": "Thu, 12 Aug 2021 08:04:41 +0800", "author": "", "description": "云原生与数据湖是当今大数据领域最热的 2 个话题，本文着重从为什么传统数仓 无法满足业务需求? 为何需要建设数据湖？数据湖整体技术架构、Apache Hudi 存储模式与视图、如何解决冷数据频繁更新、如何在数据湖上进行准实时 分析、数据湖上调度为何选型 Apache DolphinScheduler、二次开发新特性以及规划等多个角度进行了...", "shortDescription": "云原生与数据湖是当今大数据领域最热的 2 个话题，本文着重从为什么传统数仓 无法满足业务需求? 为何需要建设数据湖？数据湖整体技术架构、Apache Hudi 存储模式与视图、如何解决冷数据频繁更新、如何在数据湖上进行准实时 分析、数据湖上...", "isRead": false}, {"title": "Android 12 Beta 4 发布，已达到平台稳定性", "link": "https://www.oschina.net/news/154966/android-12-beta-4-released", "time": "Thu, 12 Aug 2021 07:36:47 +0800", "author": "", "description": "Google 今天发布了 Android 12 的第四个 Beta 版本，并进入了发布的最后阶段。这也意味着 Android 12 的 API 和所有面向应用的行为都已最终确定。对于应用程序来说，现在的重点是兼容性和质量，以便在今年晚些时候随着 Android 12 的正式发布一同推出。 此前没有注册登记测试版的开发者可以点击链接获得 Beta 4 的推送，...", "shortDescription": "Google 今天发布了 Android 12 的第四个 Beta 版本，并进入了发布的最后阶段。这也意味着 Android 12 的 API 和所有面向应用的行为都已最终确定。对于应用程序来说，现在的重点是兼容性和质量，以便在今年晚些时候...", "isRead": false}, {"title": "Universal Media Server 10.9.0 发布，媒体文件传输工具", "link": "https://www.oschina.net/news/154962/universal-media-server-10-9-0-released", "time": "Thu, 12 Aug 2021 07:19:23 +0800", "author": "", "description": "Universal Media Server 是一个兼容 DLNA，UPnP 和 HTTP/S 的媒体服务器，支持所有主要操作系统，包括 Windows，Linux 和 macOS 版本，几乎不需要配置就可以流式传输或转码许多不同的媒体格式。 Universal Media Server 10.9.0 发布，该版本更新内容如下： 通用： 增加了在网页界面下载文件夹作为播放列表的选项； 增加了...", "shortDescription": "Universal Media Server 是一个兼容 DLNA，UPnP 和 HTTP/S 的媒体服务器，支持所有主要操作系统，包括 Windows，Linux 和 macOS 版本，几乎不需要配置就可以流式传输或转码许多不同的媒体格式...", "isRead": false}, {"title": "DataEase 开源数据可视化分析平台 v1.1.0 发布，支持 Oracle 数据源", "link": "https://www.oschina.net/news/154910/dataease-1-1-0-released", "time": "Wed, 11 Aug 2021 17:53:42 +0800", "author": "", "description": "8月9日，DataEase开源数据可视化分析平台正式发布v1.1.0版本。在该版本中，新增了对Oracle数据源的支持，同时还新增两大功能：即消息中心和定时任务中心。在消息中心内，用户可以获取到系统发给自己的系统事件通知。在定时任务中心内，用户可对数据集的定时同步任务做统一的全生命周期管理。此外，我们还对数据集、视图、...", "shortDescription": "8月9日，DataEase开源数据可视化分析平台正式发布v1.1.0版本。在该版本中，新增了对Oracle数据源的支持，同时还新增两大功能：即消息中心和定时任务中心。在消息中心内，用户可以获取到系统发给自己的系统事件通知。在定时任务中心内，...", "isRead": false}, {"title": "EventMesh v1.2.0 发布，新增 7 名 contributor（务必阅读！！！）", "link": "https://www.oschina.net/news/154889/eventmesh-1-2-0-released", "time": "Wed, 11 Aug 2021 16:39:06 +0800", "author": "", "description": "作者：薛炜明 这个版本是EventMesh进入apache孵化的首个版本，我非常荣幸能够担任本次EventMesh这个大版本的Release Manager。 在这个版本中，社区贡献者们完成了大量的优化和问题修复，极大地提高了应用的安全性、稳定性、可用性，上线版本的新功能特性以及修复优化，主要是以几个方面： 特性介绍 Connector&Adaptor 可...", "shortDescription": "作者：薛炜明 这个版本是EventMesh进入apache孵化的首个版本，我非常荣幸能够担任本次EventMesh这个大版本的Release Manager。 在这个版本中，社区贡献者们完成了大量的优化和问题修复，极大地提高了应用的安全性、...", "isRead": false}, {"title": "Android Studio Arctic Fox (2020.3.1) 稳定版正式发布", "link": "https://www.oschina.net/news/154840", "time": "Wed, 11 Aug 2021 14:27:26 +0800", "author": "", "description": "作者 / Amanda Alexander, Android 产品经理 我们高兴地宣布，Android Studio Arctic Fox 现已正式进入稳定版发布渠道，欢迎大家下载。这个最新版本支持 Jetpack Compose 1.0，用于构建原生界面的 Android 全新工具包。另外，此版本也强调对多设备类型的覆盖，包括 Wear OS 设备，并提供新版后台任务管理器等功能，帮助开...", "shortDescription": "作者 / Amanda Alexander, Android 产品经理 我们高兴地宣布，Android Studio Arctic Fox 现已正式进入稳定版发布渠道，欢迎大家下载。这个最新版本支持 Jetpack Compose 1.0，...", "isRead": false}, {"title": "RT-Thread 国产 MCU 移植贡献活动开启", "link": "https://www.oschina.net/news/154833", "time": "Wed, 11 Aug 2021 13:35:58 +0800", "author": "", "description": "2020年下半年开始，史无前例的芯片缺货潮拉开大幕。供需失衡之下，芯片的交期和价格不断拉升，其中以国外大牌MCU最为夸张，一度出现价格上涨几十倍，有钱买不到货的局面。在此背景下，不少中小型终端制造企业纷纷投身国产芯片阵营，掀起新一轮国产替代浪潮。 本次RT-Thread发起一场国产MCU移植贡献活动，邀请广大开发者一...", "shortDescription": "2020年下半年开始，史无前例的芯片缺货潮拉开大幕。供需失衡之下，芯片的交期和价格不断拉升，其中以国外大牌MCU最为夸张，一度出现价格上涨几十倍，有钱买不到货的局面。在此背景下，不少中小型终端制造企业纷纷投身国产芯片阵营，掀起新一轮国产替代...", "isRead": false}, {"title": "elementary OS 6“Odin”发布，迄今为止最大的更新", "link": "https://www.oschina.net/news/154785/elementary-os-6-released", "time": "Wed, 11 Aug 2021 09:05:13 +0800", "author": "", "description": "elementary OS 6 “Odin” 现已发布。官方表示，这是该平台迄今为止最大的更新。该版本专注于： 使用户能够控制并表达自己 不断创新新功能 使 elementary OS 更容易获得且更具包容性 下载地址：https://elementary.io/ elementary OS 6.0 的主要更新内容包括有：提供了一种新的 dark style、使用 Flatpak 围绕应用程序沙...", "shortDescription": "elementary OS 6 “Odin” 现已发布。官方表示，这是该平台迄今为止最大的更新。该版本专注于： 使用户能够控制并表达自己 不断创新新功能 使 elementary OS 更容易获得且更具包容性 下载地址：https://el...", "isRead": false}, {"title": "WireGuardNT：Windows 内核下的高性能 WireGuard 实现", "link": "https://www.oschina.net/news/154780/wireguardnt-for-windows", "time": "Wed, 11 Aug 2021 08:35:56 +0800", "author": "", "description": "WireGuard 作者 Jason Donenfeld 最近宣布了 WireGuardNT 项目，这是面向 Windows 内核的 WireGuard 原生移植。和其他版本一样，WireGuardNT 的小写为 \"wireguard-nt\"，它一开始只是 Linux 版本代码库的端口。经过初步移植工作取得成功后，NT 代码库迅速分化，以更好地适应原生 NTisms 和 NDIS（Windows 网络栈）API。最...", "shortDescription": "WireGuard 作者 Jason Donenfeld 最近宣布了 WireGuardNT 项目，这是面向 Windows 内核的 WireGuard 原生移植。和其他版本一样，WireGuardNT 的小写为 \"wireguard-nt...", "isRead": false}, {"title": "Mozilla 测试 Firefox/100.0 用户代理，检查网站兼容性", "link": "https://www.oschina.net/news/154779/firefox-test-user-agent-100-version", "time": "Wed, 11 Aug 2021 08:34:33 +0800", "author": "", "description": "随着今天 Mozilla 更新了 Firefox 浏览器，Firefox 的版本号已经到达了 91。虽然目前的版本号仍然是两位数，但按照官方的升级路线图，明年 3 月 Mozilla 将发布 Firefox Nightly 100，为此 Mozilla 发起了一项实验，他们将 Firefox 浏览器的用户代理提前更改为三位数的 \"Firefox/100.0\" 版本，以此来测试未来将 Firefox ...", "shortDescription": "随着今天 Mozilla 更新了 Firefox 浏览器，Firefox 的版本号已经到达了 91。虽然目前的版本号仍然是两位数，但按照官方的升级路线图，明年 3 月 Mozilla 将发布 Firefox Nightly 100，为此 M...", "isRead": false}, {"title": "英特尔为其 C/C++ 编译器全面采用 LLVM", "link": "https://www.oschina.net/news/154778/intel-adoption-of-llvm-complete-icx", "time": "Wed, 11 Aug 2021 08:30:46 +0800", "author": "", "description": "英特尔的长期编译器专家 James Reinders 在一篇博客中透露，他们将在下一代英特尔 C/C++ 编译器中使用 LLVM 开源基础架构；并分享了一些相关信息。 “LLVM 有助于我们实现为英特尔架构提供最佳 C/C++ 编译器的目标。最新的英特尔 C/C++ 编译器使用 LLVM，可提供更快的编译时间、更好的优化、增强的标准支持，以及对 GPU ...", "shortDescription": "英特尔的长期编译器专家 James Reinders 在一篇博客中透露，他们将在下一代英特尔 C/C++ 编译器中使用 LLVM 开源基础架构；并分享了一些相关信息。 “LLVM 有助于我们实现为英特尔架构提供最佳 C/C++ 编译器的目标...", "isRead": false}, {"title": "小米推出开源机器人伴侣，计划设立开源社区", "link": "https://www.oschina.net/news/154777/xiaomi-open-source-community", "time": "Wed, 11 Aug 2021 08:10:29 +0800", "author": "", "description": "在 8 月 10 日晚举办的 2021 雷军年度演讲、小米秋季新品发布会上，雷军向大众展示了小米内部的一个探索概念项目，即小米第一代仿生四足机器人 CyberDog（中文名“铁蛋”），一款开发人员可以构建的开源机器人伴侣。 根据介绍，CyberDog 是小米首次涉足全球开源社区和开发人员的四足机器人；其基于目前仿生机器人各领域的...", "shortDescription": "在 8 月 10 日晚举办的 2021 雷军年度演讲、小米秋季新品发布会上，雷军向大众展示了小米内部的一个探索概念项目，即小米第一代仿生四足机器人 CyberDog（中文名“铁蛋”），一款开发人员可以构建的开源机器人伴侣。 根据介绍，Cyb...", "isRead": false}]}, {"feed_link": "https://www.oschina.net/project/rss", "feed_title": "OSCHINA 社区最新软件", "feed_subtitle": "OSCHINA 社区——找到您想要的开源软件，分享和交流", "feed_article_list": [{"title": "快速、轻量级的广告拦截插件 AdGuard", "link": "https://www.oschina.net/p/adguard", "time": "Fri, 13 Aug 2021 18:33:32 +0800", "author": "", "description": "AdGuard 是一种快速、轻量级的广告拦截浏览器扩展程序，可有效拦截所有类型的广告和跟踪器。专注于高级隐私保护功能，不仅可以阻止已知跟踪器，还可以防止网站构建您的影子配置文件。 AdGuard 不会收集有关您的任何信息，也不参与任何可接受的广告计划。 安装 基于 Chrome 和 Chromium 的浏览器 可以从 Chrome Web Store 获取最新的可用 AdGuard 扩展。 Firefox 可以从 Mozilla 附加组件网站获取最新版本的 AdGuard 扩展。 Oper...", "shortDescription": "AdGuard 是一种快速、轻量级的广告拦截浏览器扩展程序，可有效拦截所有类型的广告和跟踪器。专注于高级隐私保护功能，不仅可以阻止已知跟踪器，还可以防止网站构建您的影子配置文件。 AdGuard 不会收集有关您的任何信息，也不参与任何可接受...", "isRead": false}, {"title": "无代码框架 ToolJet", "link": "https://www.oschina.net/p/tooljet", "time": "Fri, 13 Aug 2021 18:22:51 +0800", "author": "", "description": "ToolJet 是一个开源的无代码框架，无需工程团队付出太多努力即可快速构建和部署内部工具。你可以连接到你的数据源，例如数据库（如 PostgreSQL、MongoDB、Elasticsearch 等）、API 端点（ToolJet 支持导入 OpenAPI 规范和 OAuth2 授权）和外部服务（如 Stripe、Slack、Google Sheets、Airtable）并使用预先构建的 UI 小部件来构建内部工具。 特性： 带有表格、图表、模态、按钮、下拉菜单等小部件的可视化应用程序构建器 Mobile...", "shortDescription": "ToolJet 是一个开源的无代码框架，无需工程团队付出太多努力即可快速构建和部署内部工具。你可以连接到你的数据源，例如数据库（如 PostgreSQL、MongoDB、Elasticsearch 等）、API 端点（ToolJet 支持导...", "isRead": false}, {"title": "基于 Swift 的多窗口浏览器 He3", "link": "https://www.oschina.net/p/he3", "time": "Fri, 13 Aug 2021 18:18:08 +0800", "author": "", "description": "He3 是一个多窗口、浮动的浏览器。He3 允许你在保持工作效率的同时观看媒体、浏览网页和做更多事情。即使在你切换任务时，你的内容也不会隐藏于其他窗口后面。 He3 支持的偏好设置包括： 自动隐藏标题 可定制的半透明模式 自定义大小和位置 所有 He3 窗口都是非激活面板，它们的目的是不妨碍用户的工作。 一些更复杂的特性： 浮动在全屏应用程序（如 Keynote 或 Powerpoint）上方 从 Safari 共享网页链接等 支持认证 cookies 无...", "shortDescription": "He3 是一个多窗口、浮动的浏览器。He3 允许你在保持工作效率的同时观看媒体、浏览网页和做更多事情。即使在你切换任务时，你的内容也不会隐藏于其他窗口后面。 He3 支持的偏好设置包括： 自动隐藏标题 可定制的半透明模式 自定义大小和位置 ...", "isRead": false}, {"title": "监控和调试 Kubernetes 集群 BotKube", "link": "https://www.oschina.net/p/botkube", "time": "Fri, 13 Aug 2021 18:14:14 +0800", "author": "", "description": "BotKube 与 Slack、Mattermos t或 Microsoft Teams 的集成帮助你监控你的 Kubernetes 集群，调试关键的部署，并通过对 Kubernetes 资源的检查给出标准做法的建议。你也可以要求BotKube在k8s集群上执行kubectl命令，这有助于调试一个应用程序或集群。 Informer Controller：将 Informer注册到 kube-apiserver 以观察配置的 k8s 资源上的事件。它将传入的 k8s 事件转发到事件管理器。 事件管理器：从 k8s 事件对象中提取所需字段并...", "shortDescription": "BotKube 与 Slack、Mattermos t或 Microsoft Teams 的集成帮助你监控你的 Kubernetes 集群，调试关键的部署，并通过对 Kubernetes 资源的检查给出标准做法的建议。你也可以要求BotKu...", "isRead": false}, {"title": "基于 Kubernetes 的 Serverless 平台 Space Cloud", "link": "https://www.oschina.net/p/space-cloud", "time": "Fri, 13 Aug 2021 18:07:02 +0800", "author": "", "description": "Space Cloud 是一个基于 Kubernetes 的 Serverless 平台，可在任何数据库上提供即时、实时的 API，为您的自定义业务逻辑提供事件触发器和统一 API 。 在大多数情况下，Space Cloud 可帮助你构建现代应用程序，而无需编写任何后端代码。它提供了GraphQL和REST API，你的前端可以以安全的方式直接使用它们。 Space Cloud 旨在通过以下方式简化平台开发： 消除需要写在大多数情况下，任何后端代码。 提供一种简单的方法来为高级用例...", "shortDescription": "Space Cloud 是一个基于 Kubernetes 的 Serverless 平台，可在任何数据库上提供即时、实时的 API，为您的自定义业务逻辑提供事件触发器和统一 API 。 在大多数情况下，Space Cloud 可帮助你构建现...", "isRead": false}, {"title": "开源 Laravel 电子商务框架 Bagisto", "link": "https://www.oschina.net/p/bagisto", "time": "Fri, 13 Aug 2021 17:06:28 +0800", "author": "", "description": "Bagisto 是一个免费的开源 Laravel 电子商务框架，专为构建和扩展你的业务而构建。它建立在一些最热门的开源技术上，例如 Laravel（一个 PHP 框架）和 一个渐进式 Javascript 框架 Vue.js。 Bagisto 可以帮助你减少建立网上商店的时间、成本和劳动力，或者从实体店迁移到要求越来越高的网络世界。你的企业--无论是小型还是大型--都可以从中受益。而且，它的设置非常简单。 功能： 多个渠道、区域设置、货币。 内置访问控制层。 ...", "shortDescription": "Bagisto 是一个免费的开源 Laravel 电子商务框架，专为构建和扩展你的业务而构建。它建立在一些最热门的开源技术上，例如 Laravel（一个 PHP 框架）和 一个渐进式 Javascript 框架 Vue.js。 Bagist...", "isRead": false}, {"title": "本地 AWS 云堆栈 LocalStack", "link": "https://www.oschina.net/p/localstack", "time": "Fri, 13 Aug 2021 16:57:51 +0800", "author": "", "description": "LocalStack 是一个功能齐全的本地 AWS 云堆栈，在离线状态下开发和测试你的云和无服务器应用程序。为开发云应用程序提供了一个易于使用的测试/模拟框架。它在你的本地机器上启动一个测试环境，提供与真正的 AWS 云环境相同的功能和 API。 你可以运行你的 Lambda 函数、将数据存储到 DynamoDB 表、通过 Kinesis 流反馈事件、将你的应用程序置于 API 网关之后等等。而所有这一切都发生在你的本地机器上，而无需与云端对话。 特点：...", "shortDescription": "LocalStack 是一个功能齐全的本地 AWS 云堆栈，在离线状态下开发和测试你的云和无服务器应用程序。为开发云应用程序提供了一个易于使用的测试/模拟框架。它在你的本地机器上启动一个测试环境，提供与真正的 AWS 云环境相同的功能和 A...", "isRead": false}, {"title": "CC校庆小程序 cc-cel", "link": "https://www.oschina.net/p/cc-cel", "time": "Fri, 13 Aug 2021 13:41:45 +0800", "author": "", "description": "项目介绍 本小程序包括校庆公告，校史大事记，校庆指南，活动安排，校友捐赠，返校信息，校友登记，校庆头像等八大功能模块！ 让同学们与校友们不在学校也能参与到校庆活动之中。动动手指，你也一样可以亲身参加校庆活动！为亲爱的母校应援！ 功能说明 技术运用 项目使用微信小程序平台进行开发。 使用腾讯云开发技术，免费资源配额，无需域名和服务器即可搭建。 小程序本身的即用即走，适合小工具的使用场景，也适合程序的开发...", "shortDescription": "项目介绍 本小程序包括校庆公告，校史大事记，校庆指南，活动安排，校友捐赠，返校信息，校友登记，校庆头像等八大功能模块！ 让同学们与校友们不在学校也能参与到校庆活动之中。动动手指，你也一样可以亲身参加校庆活动！为亲爱的母校应援！ 功能说明 技...", "isRead": false}, {"title": "Markdown 编辑器框架 Milkdown", "link": "https://www.oschina.net/p/milkdown", "time": "Fri, 13 Aug 2021 12:14:11 +0800", "author": "", "description": "Milkdown 是插件驱动的所见即所得的 Markdown 编辑器框架。它由两部分组成： 一个小巧的核心，提供了插件加载器和一些内置插件。 大量的插件，包括语法、命令和组件。 通过这种模式，开发者可以根据喜好开启或关闭语法和功能，例如表格，数学公式或斜线指令。当然也可以创造自己的插件来实现想法。 特性 所见即所得的 Markdown - 以一种优雅的方式编写 markdown 可定制主题 - 主题可以通过 npm 包安装和共享 可交互 - 通过插件支...", "shortDescription": "Milkdown 是插件驱动的所见即所得的 Markdown 编辑器框架。它由两部分组成： 一个小巧的核心，提供了插件加载器和一些内置插件。 大量的插件，包括语法、命令和组件。 通过这种模式，开发者可以根据喜好开启或关闭语法和功能，例如表格...", "isRead": false}, {"title": "新一代通用 Mapper MyBatis Mapper", "link": "https://www.oschina.net/p/io-mybatis-mapper", "time": "Fri, 13 Aug 2021 10:17:43 +0800", "author": "", "description": "项目地址：https://mapper.mybatis.io 介绍 这是一个不需要任何配置就可以直接使用的通用 Mapper，通过简单的学习就可以直接在项目中使用。 1.1 主要目标 1. 开箱即用，无需任何配置，继承基类 Mapper 即可获得大量通用方法； 2. 随心所欲，通过复制粘贴的方式可以组建自己的基类 Mapper； 3. 全面贴心，提供 Service 层的封装方便业务使用和理解 Mapper； 4. 简单直观，提供 ActiveRecord 模式，结合 Spring Boot 自动配置直接...", "shortDescription": "项目地址：https://mapper.mybatis.io 介绍 这是一个不需要任何配置就可以直接使用的通用 Mapper，通过简单的学习就可以直接在项目中使用。 1.1 主要目标 1. 开箱即用，无需任何配置，继承基类 Mapper 即...", "isRead": false}, {"title": "支持全平台的开源密码管理器 Bitwarden", "link": "https://www.oschina.net/p/bitwarden", "time": "Thu, 12 Aug 2021 18:07:35 +0800", "author": "", "description": "Bitwarden 桌面应用程序是使用 Electron 和 Angular 编写的。该应用程序安装在 Windows、macOS 和 Linux 发行版上。 构建/运行 要求 Node.js v14.17 或更高版本 NPM v7 Windows 用户：要编译应用程序中使用的本机节点模块，需要 Visual C++ 工具集，可通过标准 Visual Studio 安装程序获得。还需要安装 Microsoft Build Tools 2015 和 Windows 10 SDK 17134 作为 Visual Studio 安装程序中的附加依赖项。 运行应用程序 \nnpm in...", "shortDescription": "Bitwarden 桌面应用程序是使用 Electron 和 Angular 编写的。该应用程序安装在 Windows、macOS 和 Linux 发行版上。 构建/运行 要求 Node.js v14.17 或更高版本 NPM v7 Win...", "isRead": false}, {"title": "用于设置和实施安全策略的 GitHub 应用程序 Allstar", "link": "https://www.oschina.net/p/allstar", "time": "Thu, 12 Aug 2021 17:53:21 +0800", "author": "", "description": "Allstar 是安装在组织或存储库上的 GitHub 应用程序，用于设置和实施安全策略。其目标是能够持续监控和检测任何可能有风险或不遵循安全最佳实践的 GitHub 设置或存储库文件内容。如果 Allstar 发现存储库不合规，它将采取措施，例如创建问题或恢复安全设置。 具体策略高度可配置，以尽量满足不同项目社区和组织的需求。此外，制定和贡献新政策也很容易。Allstar 是在 OpenSSF 组织下开发的，作为保护关键项目工作组的一部分。 ...", "shortDescription": "Allstar 是安装在组织或存储库上的 GitHub 应用程序，用于设置和实施安全策略。其目标是能够持续监控和检测任何可能有风险或不遵循安全最佳实践的 GitHub 设置或存储库文件内容。如果 Allstar 发现存储库不合规，它将采取措...", "isRead": false}, {"title": "构建和自托管内部应用程序 Appsmith", "link": "https://www.oschina.net/p/appsmith", "time": "Thu, 12 Aug 2021 17:43:40 +0800", "author": "", "description": "Appsmith 是一个开源框架，用于构建管理面板、CRUD 应用程序和工作流。构建你需要的一切，速度提高 10 倍。允许你拖放组件来构建仪表板、使用 JavaScript 对象编写逻辑并连接到任何 API、数据库或 GraphQL 源。 原则： 使用 UI 组件创建页面 将 Appsmith 连接到你的数据源，如 REST API、MySQL、Postgres、MongoDB 和其他数据库。 在 SQL 或 JS 编辑器中编写查询和业务逻辑 将 UI 绑定到你的查询响应或业务逻辑 单击即可部署你的...", "shortDescription": "Appsmith 是一个开源框架，用于构建管理面板、CRUD 应用程序和工作流。构建你需要的一切，速度提高 10 倍。允许你拖放组件来构建仪表板、使用 JavaScript 对象编写逻辑并连接到任何 API、数据库或 GraphQL 源。 ...", "isRead": false}, {"title": "跳过网页重定向的浏览器插件 Skip Redirect", "link": "https://www.oschina.net/p/skip-redirect", "time": "Thu, 12 Aug 2021 17:37:43 +0800", "author": "", "description": "一些网页在重定向到最终页面之前使用中间页面。Skip Redirect 就是一个尝试从中间 url 中提取最终 url 的插件，如果成功提取则会立即跳转至最终页面。 默认情况下，除了与 no-skip-urls-list 相匹配的 URL 外，所有的 URL 都被检查为嵌入式 URL，并跳过重定向。根据访问的页面，这可能会导致登录功能障碍等问题。可以对 no-skip-urls-list 进行编辑以避免这些问题。Skip Redirect 还有一种跳过 urls-list 模式，可以完全避免这种...", "shortDescription": "一些网页在重定向到最终页面之前使用中间页面。Skip Redirect 就是一个尝试从中间 url 中提取最终 url 的插件，如果成功提取则会立即跳转至最终页面。 默认情况下，除了与 no-skip-urls-list 相匹配的 URL ...", "isRead": false}, {"title": "全渠道客户支持软件 Chatwoot", "link": "https://www.oschina.net/p/chatwoot", "time": "Thu, 12 Aug 2021 17:29:47 +0800", "author": "", "description": "Chatwoot 是一款开源的全渠道客户支持软件，是 Intercom、Zendesk、Salesforce Service Cloud 等的开源替代品。 Chatwoot 对发生在不同沟通渠道的对话提供了一个综合视图。 它支持以下对话渠道： 网站：使用实时聊天小部件与你的客户交谈，并使用 SDK 来识别用户并提供上下文支持。 Facebook：连接你的 Facebook 页面并开始回复直接消息到您的页面。 Twitter：连接你的 Twitter 个人资料并回复直接消息或提及您的推文。 Whatsa...", "shortDescription": "Chatwoot 是一款开源的全渠道客户支持软件，是 Intercom、Zendesk、Salesforce Service Cloud 等的开源替代品。 Chatwoot 对发生在不同沟通渠道的对话提供了一个综合视图。 它支持以下对话渠道...", "isRead": false}, {"title": "基于 WebExtensions 的隐私保护插件 ClearURLs", "link": "https://www.oschina.net/p/clearurls", "time": "Thu, 12 Aug 2021 17:22:52 +0800", "author": "", "description": "ClearURLs 是基于新 WebExtensions 技术的附加组件，并针对 Firefox 和 Chrome 浏览器进行了优化。 此扩展程序将自动从 URL 中删除跟踪元素，以帮助在浏览 Internet 时保护您的隐私。 应用 许多网站使用 URL 中的跟踪元素（例如https://example.com?utm_source=newsletter1&utm_medium=email&utm_campaign=sale）来标记用户的在线活动。所有这些跟踪代码对于网站的显示或正常工作都不是必需的，因此可以删除 —— 而这正是 Clea...", "shortDescription": "ClearURLs 是基于新 WebExtensions 技术的附加组件，并针对 Firefox 和 Chrome 浏览器进行了优化。 此扩展程序将自动从 URL 中删除跟踪元素，以帮助在浏览 Internet 时保护您的隐私。 应用 许多...", "isRead": false}, {"title": "移动优先的 React Native 和 Web 组件库 NativeBase", "link": "https://www.oschina.net/p/nativebase", "time": "Thu, 12 Aug 2021 17:18:15 +0800", "author": "", "description": "NativeBase 是一个移动优先的 React 和 React Native 组件库，可帮助你跨 Android、iOS 和 Web (alpha) 构建一致的设计系统。 特点： 开箱即用的可访问性。与 React ARIA 和 React Native ARIA 集成，提供 React 钩子。这使你能够立即构建可访问的设计系统。 支持 Utility Props。由Styled System提供支持，因此你可以使用基于约束的实用程序样式道具快速构建自定义 UI 组件。 丰富的组件库。NativeBase 提供了大约 40 个组件，...", "shortDescription": "NativeBase 是一个移动优先的 React 和 React Native 组件库，可帮助你跨 Android、iOS 和 Web (alpha) 构建一致的设计系统。 特点： 开箱即用的可访问性。与 React ARIA 和 Rea...", "isRead": false}, {"title": "开源 API 开发生态系统 Hoppscotch", "link": "https://www.oschina.net/p/hoppscotch", "time": "Thu, 12 Aug 2021 17:02:28 +0800", "author": "", "description": "Hoppscotch 是一个开源 API 开发生态系统。 特性： 轻量级：采用简约的 UI 设计。 快速：实时发送请求和获取/复制响应。 Make it yours：背景、前景色和强调色的可定制组合。立即定制 Request：立即从端点检索响应。 WebSocket：通过单个 TCP 连接建立全双工通信通道。 Server Sent Events：通过 HTTP 连接从服务器接收更新流，而无需轮询。 Socket.IO：使用 SocketIO 服务器发送和接收数据。 MQTT：订阅和发布到 MQTT Broker ...", "shortDescription": "Hoppscotch 是一个开源 API 开发生态系统。 特性： 轻量级：采用简约的 UI 设计。 快速：实时发送请求和获取/复制响应。 Make it yours：背景、前景色和强调色的可定制组合。立即定制 Request：立即从端点检索...", "isRead": false}, {"title": "应用使用时长追踪软件 Tockler", "link": "https://www.oschina.net/p/tockler", "time": "Thu, 12 Aug 2021 16:55:54 +0800", "author": "", "description": "Tockler 是一款能够通过监视活动窗口和空闲时间来跟踪使用时间的跨平台应用程序。 自动跟踪应用程序使用情况和工作时间 有了 Tockler，您可以回到过去，看看您在做什么。您可以获取有关使用了哪些应用程序的信息 - 确切地说是在什么时间 - 以及该应用程序当时的标题。这足以确定你做了多少事情。 跟踪您在计算机上的花费时间 Tockler 跟踪活动应用程序的使用情况和计算机状态。它记录活动的应用程序标题。它跟踪空闲、离线和在线...", "shortDescription": "Tockler 是一款能够通过监视活动窗口和空闲时间来跟踪使用时间的跨平台应用程序。 自动跟踪应用程序使用情况和工作时间 有了 Tockler，您可以回到过去，看看您在做什么。您可以获取有关使用了哪些应用程序的信息 - 确切地说是在什么时间...", "isRead": false}, {"title": "简化 K3s 的集群管理 AutoK3s", "link": "https://www.oschina.net/p/autok3s", "time": "Thu, 12 Aug 2021 14:58:21 +0800", "author": "", "description": "AutoK3s 是一个轻量级的工具，用于简化 K3s 的集群管理，它可以帮助你 Run K3s Everywhere。 主要特性： 通过 API、CLI 和 UI 等方式快速创建 K3s。 云提供商集成（简化 CCM 设置）。 灵活安装选项，例如 K3s 集群 HA 和数据存储（内置 etcd、RDS、SQLite 等）。 低成本（尝试云中的竞价实例）。 通过 UI 简化操作。 多云之间弹性迁移，借助诸如 backup-restore-operator 这样的工具进行弹性迁移。 AutoK3s 可以支持以下云厂商，...", "shortDescription": "AutoK3s 是一个轻量级的工具，用于简化 K3s 的集群管理，它可以帮助你 Run K3s Everywhere。 主要特性： 通过 API、CLI 和 UI 等方式快速创建 K3s。 云提供商集成（简化 CCM 设置）。 灵活安装选项...", "isRead": false}, {"title": "Java 系统代理组件 EaseAgent", "link": "https://www.oschina.net/p/easeagent", "time": "Thu, 12 Aug 2021 14:37:00 +0800", "author": "", "description": "EaseAgent 是 Java 系统代理组件。 目标 EaseAgent 是 APM（应用性能管理）系统的 Java 代理。 EaseAgent 主要专注于 Spring Boot 开发环境。 EaseAgent 兼容主流监控生态系统，如 Kafka、ElasticSearch、Prometheus、Zipkin 等。 EaseAgent 收集基本指标和服务跟踪日志，对于性能分析和故障排除非常有帮助。 原则 旨在为微服务架构而设计，从服务的角度收集数据。 以非侵入性方式检测 Java 应用程序。 轻量级且非常低的 CPU、内...", "shortDescription": "EaseAgent 是 Java 系统代理组件。 目标 EaseAgent 是 APM（应用性能管理）系统的 Java 代理。 EaseAgent 主要专注于 Spring Boot 开发环境。 EaseAgent 兼容主流监控生态系统，如...", "isRead": false}, {"title": "Java 生态的服务网格治理 EaseMesh", "link": "https://www.oschina.net/p/easemesh", "time": "Thu, 12 Aug 2021 14:26:22 +0800", "author": "", "description": "EaseMesh 是一个更好的服务治理的解决方案，它是完全基于服务的视角进行增强和治理，致力于实现更好地诊断服务运行时的问题和监控服务状态。它还具有丰富的服务治理功能。EaseMesh 专注于 Java 领域。为 Java 应用提供最低的迁移成本。它符合 Kubernetes 标准，易于与基于 Kubernetes 的解决方案进行集成。 原则 Spring Cloud兼容性： Spring Cloud 领域服务治理和弹力容错设计。 无需修改代码： 使用Sidecar和JavaAgent来完成服...", "shortDescription": "EaseMesh 是一个更好的服务治理的解决方案，它是完全基于服务的视角进行增强和治理，致力于实现更好地诊断服务运行时的问题和监控服务状态。它还具有丰富的服务治理功能。EaseMesh 专注于 Java 领域。为 Java 应用提供最低的迁...", "isRead": false}, {"title": "CC校友登记小程序 ccreg", "link": "https://www.oschina.net/p/ccreg", "time": "Thu, 12 Aug 2021 10:18:17 +0800", "author": "", "description": "本产品用于各高校/中学的校友会，地方校友组织收集，登记，管理，核实校友资料； 登记后的用户可以根据姓名/院系/入学年份/行业/单位一键查找；校友是宝贵的人脉财富，5G时代各大高校都非常重视校友工作。 功能说明 特色特点 简约：不臃肿，主打内容极简，功能简洁直击痛点 安全：保护校友的信息安全，隐私内容仅后台管理员后可见。 方便：上传自己的个人信息，方便在需要时取得联系。小程序无需下载APP随用随走。 技术运用 项目...", "shortDescription": "本产品用于各高校/中学的校友会，地方校友组织收集，登记，管理，核实校友资料； 登记后的用户可以根据姓名/院系/入学年份/行业/单位一键查找；校友是宝贵的人脉财富，5G时代各大高校都非常重视校友工作。 功能说明 特色特点 简约：不臃肿，主打内...", "isRead": false}, {"title": "基于 SpringBoot 的在线云盘 epan", "link": "https://www.oschina.net/p/epan", "time": "Wed, 11 Aug 2021 19:08:48 +0800", "author": "", "description": "epan 是基于 SpringBoot 的在线云盘, 支持对接 Hadoop, 又拍云 存储源 介绍 基于 SpringBoot 的在线云盘 SpringBoot + MyBatis + Maven + MySQL 文件存储于 Hadoop HDFS, 又拍云 中 技术 秒传 从文件中计算特征值，查询数据库，若已存在，则更新数据库指向目标文件，服务端相同文件只存一份。 多文件上传 多个文件加入队列，逐个发送到服务端 删除 删除文件夹：递归删除文件夹下所有文件，仅当物理文件没有被 引用时，才被删除，...", "shortDescription": "epan 是基于 SpringBoot 的在线云盘, 支持对接 Hadoop, 又拍云 存储源 介绍 基于 SpringBoot 的在线云盘 SpringBoot + MyBatis + Maven + MySQL 文件存储于 Hadoop...", "isRead": false}, {"title": "ASP.NET Core 轻量级插件框架 PluginCore", "link": "https://www.oschina.net/p/plugincore", "time": "Wed, 11 Aug 2021 18:17:00 +0800", "author": "", "description": "PluginCore 是适用于 ASP.NET Core 的轻量级插件框架。 介绍 适用于 ASP.NET Core 的轻量级插件框架 简单 - 约定优于配置, 以最少的配置帮助你专注于业务 开箱即用 - 前后端自动集成 动态 WebAPI - 每个插件都可新增 Controller, 拥有自己的路由 热插拔 - 安装、启用、禁用、卸载 均无需重启站点 易扩展 - 你可以编写你自己的插件sdk, 然后引用插件sdk, 编写扩展插件 - 自定义插件钩子, 并应用 无需数据库 - 无数据库依赖 0侵入...", "shortDescription": "PluginCore 是适用于 ASP.NET Core 的轻量级插件框架。 介绍 适用于 ASP.NET Core 的轻量级插件框架 简单 - 约定优于配置, 以最少的配置帮助你专注于业务 开箱即用 - 前后端自动集成 动态 WebAPI...", "isRead": false}, {"title": "分布式矢量搜索引擎 Vald", "link": "https://www.oschina.net/p/vald", "time": "Wed, 11 Aug 2021 17:23:53 +0800", "author": "", "description": "Vald 是一个高度可扩展的分布式快速近似近邻密集矢量搜索引擎。 Vald 是基于 Cloud-Native 架构设计和实现的。它使用最快的 ANN 算法 NGT 来搜索 neighbors。Vald 具有自动矢量索引和索引备份，以及从数十亿特征矢量数据中进行搜索的水平缩放。Vald 易于使用、功能丰富且可根据您的需要高度定制。 主要特点 异步自动索引 通常图形在索引期间需要锁定，这会导致停止世界。但是 Vald 使用分布式索引图，因此它在索引期间继续工作。...", "shortDescription": "Vald 是一个高度可扩展的分布式快速近似近邻密集矢量搜索引擎。 Vald 是基于 Cloud-Native 架构设计和实现的。它使用最快的 ANN 算法 NGT 来搜索 neighbors。Vald 具有自动矢量索引和索引备份，以及从数十...", "isRead": false}, {"title": "Kubernetes 原生安全工具包 Starboard", "link": "https://www.oschina.net/p/starboard", "time": "Wed, 11 Aug 2021 17:18:48 +0800", "author": "", "description": "Starboard 是一个 Kubernetes 原生安全工具包，将安全工具集成到Kubernetes环境中，这样用户就能以 Kubernetes 原生的方式找到并查看与不同资源相关的风险。 Starboard 提供了自定义的资源定义和 Go 模块，以与一系列现有的安全扫描器合作，以及一个与kubectl兼容的命令、Octant插件和Lens扩展，使安全报告可以通过熟悉的Kubernetes工具获得。 Starboard 可以在两种不同的模式下运行： 作为 command，您可以触发扫描并以与 kube...", "shortDescription": "Starboard 是一个 Kubernetes 原生安全工具包，将安全工具集成到Kubernetes环境中，这样用户就能以 Kubernetes 原生的方式找到并查看与不同资源相关的风险。 Starboard 提供了自定义的资源定义和 G...", "isRead": false}, {"title": "云原生流处理器 Siddhi", "link": "https://www.oschina.net/p/siddhi", "time": "Wed, 11 Aug 2021 17:07:39 +0800", "author": "", "description": "Siddhi 是一个云原生的流和复杂事件处理引擎，能够理解流式 SQL 查询，以便从不同的数据源捕获事件，处理它们，检测复杂的条件，并实时将输出发布到各种终端。 完全开源、云原生、可扩展、micro streaming 和复杂的事件处理系统，能够为实时分析、数据集成、通知管理和自适应决策等用例建立事件驱动的应用。 事件处理逻辑可以通过图形和源编辑器使用流式SQL查询来编写，从不同的数据源捕捉事件，处理和分析它们，与多个服务和数...", "shortDescription": "Siddhi 是一个云原生的流和复杂事件处理引擎，能够理解流式 SQL 查询，以便从不同的数据源捕获事件，处理它们，检测复杂的条件，并实时将输出发布到各种终端。 完全开源、云原生、可扩展、micro streaming 和复杂的事件处理系统...", "isRead": false}, {"title": "Java 博客建站平台 PerfreeBlog", "link": "https://www.oschina.net/p/perfreeblog", "time": "Wed, 11 Aug 2021 17:05:02 +0800", "author": "", "description": "PerfreeBlog是一款基于java开发的博客建站平台,后端采用SpringBoot、Shiro、Mybatis、Enjoy模板引擎等技术进行开发,给您带来全新的创作体验 官网地址: http://www.perfree.org.cn 文档地址: http://www.perfree.org.cn/doc 演示站点: https://www.yinpengfei.com 特性 设计简洁，界面美观 采用Markdown编辑器,支持一键插入视频、图片 支持多主题自由切换 主题在线编辑,及时生效 友情链接管理 支持附件管理 主题开发简单快速 支持...", "shortDescription": "PerfreeBlog是一款基于java开发的博客建站平台,后端采用SpringBoot、Shiro、Mybatis、Enjoy模板引擎等技术进行开发,给您带来全新的创作体验 官网地址: http://www.perfree.org.cn ...", "isRead": false}, {"title": "Python 绘图机器人 DrawBot", "link": "https://www.oschina.net/p/drawbot", "time": "Wed, 11 Aug 2021 17:02:49 +0800", "author": "", "description": "DrawBot 是一个强大的、免费的 macOS 应用程序，可以通过编写 Python 脚本来生成二维图形。内置的图形基元支持矩形、椭圆、（贝塞尔曲线）路径、多边形、文本对象、颜色、透明度等等。你可以对多页文件和定格动画进行编程。导出格式支持 PDF、SVG、PNG、JPEG、TIFF、GIF 动画和 MP4 视频。 使用 DrawBot 作为 Python 模块 DrawBot 也可以作为 Python 模块安装，不需要应用程序。 安装 最简单的方法是使用 pip： \n$ pip instal...", "shortDescription": "DrawBot 是一个强大的、免费的 macOS 应用程序，可以通过编写 Python 脚本来生成二维图形。内置的图形基元支持矩形、椭圆、（贝塞尔曲线）路径、多边形、文本对象、颜色、透明度等等。你可以对多页文件和定格动画进行编程。导出格式支...", "isRead": false}, {"title": "轻量级 Golang 编码解码、加密解密库 go-dongle", "link": "https://www.oschina.net/p/go-dongle", "time": "Wed, 11 Aug 2021 16:57:34 +0800", "author": "", "description": "go-dongle 是一个轻量级、语义化、对开发者友好的 golang 编码解码、加密解密库。 如果您觉得不错，请给个 star 吧 github.com/golang-module/dongle gitee.com/go-package/dongle 安装使用 \n// 使用 github 库\ngo get -u github.com/golang-module/dongle\nimport (\n    \"github.com/golang-module/dongle\"\n)\n// 使用 gitee 库\ngo get -u gitee.com/go-package/dongle\nimport (\n    \"gitee.com/go-package/dong...", "shortDescription": "go-dongle 是一个轻量级、语义化、对开发者友好的 golang 编码解码、加密解密库。 如果您觉得不错，请给个 star 吧 github.com/golang-module/dongle gitee.com/go-package/...", "isRead": false}, {"title": "媒体播放器的控制工具 Beardie", "link": "https://www.oschina.net/p/beardie", "time": "Wed, 11 Aug 2021 16:52:32 +0800", "author": "", "description": "Beardie 是一个允许你用键盘控制各种媒体播放器的工具。Beardie 可以管理基于网络的播放器（SoundCloud、YouTube 等）、本地应用程序播放器（Apple Music、Spotify）和 Sonos 系统。 安装： 需要 Mac OS X 10.14 或更高版本。 您可以在此处下载最新版本，为了让 Beardie 控制网络播放器，您需要启用 Beardie 设置中的启用浏览器扩展选项。 功能介绍： 支持媒体键：Beardie 支持用苹果键盘的标准媒体键控制播放器。 智能模式：B...", "shortDescription": "Beardie 是一个允许你用键盘控制各种媒体播放器的工具。Beardie 可以管理基于网络的播放器（SoundCloud、YouTube 等）、本地应用程序播放器（Apple Music、Spotify）和 Sonos 系统。 安装： 需...", "isRead": false}, {"title": "Web Audio 框架 Tone.js", "link": "https://www.oschina.net/p/tone-js", "time": "Wed, 11 Aug 2021 16:38:13 +0800", "author": "", "description": "Tone.js 是一个 Web Audio 框架，用于在浏览器中创建交互式音乐。Tone.js 的架构旨在让创建基于 Web 的音频应用程序的音乐家和音频程序员熟悉。在高层次上，Tone 提供常见的 DAW（数字音频工作站）功能，例如用于同步和安排事件的全局传输以及预构建的合成器和效果。 此外，Tone 提供高性能构建块来创建你自己的合成器、效果器和复杂的控制信号。 应用程序接口 例子 演示 \n//create a synth and connect it to the main output...", "shortDescription": "Tone.js 是一个 Web Audio 框架，用于在浏览器中创建交互式音乐。Tone.js 的架构旨在让创建基于 Web 的音频应用程序的音乐家和音频程序员熟悉。在高层次上，Tone 提供常见的 DAW（数字音频工作站）功能，例如用于同...", "isRead": false}, {"title": "ESP8266 的替代固件 Tasmota", "link": "https://www.oschina.net/p/tasmota", "time": "Wed, 11 Aug 2021 16:17:30 +0800", "author": "", "description": "Tasmota 是基于 ESP8266 和 ESP32 的设备的替代固件，使用 webUI 轻松配置、OTA 更新、使用定时器或规则的自动化、可扩展性以及完全通过 MQTT、HTTP、串行或 KNX 的本地控制。为 PlatformIO 编写，对 Arduino IDE 支持有限。 特点： 具有快速设置和更新的完全本地控制。 使用 MQTT、Web UI、HTTP 或串行进行控制。 使用计时器、规则或脚本实现自动化。 与家庭自动化解决方案集成。 令人难以置信的可扩展性和灵活性。...", "shortDescription": "Tasmota 是基于 ESP8266 和 ESP32 的设备的替代固件，使用 webUI 轻松配置、OTA 更新、使用定时器或规则的自动化、可扩展性以及完全通过 MQTT、HTTP、串行或 KNX 的本地控制。为 PlatformIO 编...", "isRead": false}, {"title": "macOS 菜单栏实用程序 Nightfall for Mac", "link": "https://www.oschina.net/p/nightfall-for-mac", "time": "Wed, 11 Aug 2021 16:14:13 +0800", "author": "", "description": "Nightfall 是一款用于快速切换 macOS 明/暗模式的菜单栏实用程序。 安装 Nightfall 需要 macOS Catalina 或更高版本 注意：该构建没有签名，因此需要用户绕过 Gatekeeper 才能运行 Nightfall。 Homebrew Nightfall 可以通过 Homebrew Cask 安装： \nbrew install --cask nightfall\n 直接下载 也可以在 Release 页面上直接下载。 屏幕录制权限 Nightfall 包括一个可选功能，可平滑进行明暗模式之间的过渡。由于它的实现方式，用...", "shortDescription": "Nightfall 是一款用于快速切换 macOS 明/暗模式的菜单栏实用程序。 安装 Nightfall 需要 macOS Catalina 或更高版本 注意：该构建没有签名，因此需要用户绕过 Gatekeeper 才能运行 Nightf...", "isRead": false}, {"title": "基于 FreeBSD 的开源操作系统 Airyx", "link": "https://www.oschina.net/p/airyx", "time": "Wed, 11 Aug 2021 16:00:36 +0800", "author": "", "description": "Airyx 是一个新的开源桌面操作系统，旨在为 x86-64 系统提供与 macOS 相似的体验和兼容性。它建立在 FreeBSD 的坚实基础上，Airyx 的目标是给人以平滑、稳定、熟悉和直观的感觉，处理你的日常任务，并尽可能地提供与激发它的商业操作系统的兼容性。 Airyx 把系统主要放在/System、/Library 和 /usr中。/usr/local 树被保留给用户添加的东西（如 FreeBSD 软件包）。用户的主目录被放在/Users下，每个用户都有一个 ~/Library 文件...", "shortDescription": "Airyx 是一个新的开源桌面操作系统，旨在为 x86-64 系统提供与 macOS 相似的体验和兼容性。它建立在 FreeBSD 的坚实基础上，Airyx 的目标是给人以平滑、稳定、熟悉和直观的感觉，处理你的日常任务，并尽可能地提供与激发...", "isRead": false}, {"title": "视频剪辑工具 Video Trimmer", "link": "https://www.oschina.net/p/video-trimmer", "time": "Wed, 11 Aug 2021 15:42:38 +0800", "author": "", "description": "Video Trimmer 是一个视频剪辑工具，可以根据开始和结束时间戳剪切视频片段。视频永远不会重新编码，因此剪辑过程非常快且不会降低视频质量。 命令行参数 您可以将输入视频路径和默认输出视频路径作为命令行参数传递： \n$ video-trimmer --output trimmed.mp4 input_video.mp4 Flatpak 版本需要一个特殊的--file-forwarding标志和@@标记来通过沙箱传递输入视频： \n$ flatpak run --file-forwarding org.gnome.gitlab.YaLTeR....", "shortDescription": "Video Trimmer 是一个视频剪辑工具，可以根据开始和结束时间戳剪切视频片段。视频永远不会重新编码，因此剪辑过程非常快且不会降低视频质量。 命令行参数 您可以将输入视频路径和默认输出视频路径作为命令行参数传递： \n$ video-t...", "isRead": false}, {"title": "开源教室 Flat", "link": "https://www.oschina.net/p/flat", "time": "Wed, 11 Aug 2021 12:50:49 +0800", "author": "", "description": "Flat 是 Agora Flat 开源教室的 Web 端、Windows 客户端与 macOS 客户端。 特性 前后端完全开源 Flat Web Flat 桌面端（Windows 与 macOS） Flat Android Flat Server 服务器 多场景课堂 大班课 小班课 一对一 实时交互 多功能互动白板 实时音视频（RTC）通讯 即时消息（RTM）聊天 举手上麦发言 帐户系统 微信登陆 GitHub 登陆 谷歌登陆 房间管理 加入、创建、预定房间 支持周期性房间 查看历史房间 课堂录制回放 白板信令回放 ...", "shortDescription": "Flat 是 Agora Flat 开源教室的 Web 端、Windows 客户端与 macOS 客户端。 特性 前后端完全开源 Flat Web Flat 桌面端（Windows 与 macOS） Flat Android Flat Se...", "isRead": false}, {"title": "响应式领域驱动基础框架 myddd-vertx", "link": "https://www.oschina.net/p/myddd-vertx", "time": "Wed, 11 Aug 2021 10:31:43 +0800", "author": "", "description": "myddd-vertx是基于Kotlin与Vertx的响应式领域驱动基础框架。它是myddd在后端的实现。 核心宗旨 myddd-vertx是myddd在后端的大胆尝试 ，myddd-vertx遵循以下宗旨： 以响应式编程为核心。在响应式框架中，选择Vert.x做为核心依赖框架。 以Kotlin取代Java，Kotlin比Java更简洁与优雅。 基于myddd-vertx的代码，无论在代码的简洁与优雅，还是在其性能上，都是传统的Java以及Spring Boot无法相比的。除了需要学习一门新的语言Kotlin，...", "shortDescription": "myddd-vertx是基于Kotlin与Vertx的响应式领域驱动基础框架。它是myddd在后端的实现。 核心宗旨 myddd-vertx是myddd在后端的大胆尝试 ，myddd-vertx遵循以下宗旨： 以响应式编程为核心。在响应式框...", "isRead": false}, {"title": "加密工具 rage", "link": "https://www.oschina.net/p/rage", "time": "Tue, 10 Aug 2021 18:27:17 +0800", "author": "", "description": "rage 是一个简单、现代、安全的文件加密工具，使用 age 格式。它的特点是小的显式密钥，没有配置选项，以及UNIX风格的可组合性。 \nUsage:\n  rage [--encrypt] -r RECIPIENT [-i IDENTITY] [-a] [-o OUTPUT] [INPUT]\n  rage --decrypt [-i IDENTITY] [-o OUTPUT] [INPUT]\nPositional arguments:\n  INPUT                       Path to a file to read from.\nOptional arguments:\n  -h, --help                  Prin...", "shortDescription": "rage 是一个简单、现代、安全的文件加密工具，使用 age 格式。它的特点是小的显式密钥，没有配置选项，以及UNIX风格的可组合性。 \nUsage:\n  rage [--encrypt] -r RECIPIENT [-i IDENTITY...", "isRead": false}, {"title": "简单可读的 DSL 语言 DBML", "link": "https://www.oschina.net/p/dbml", "time": "Tue, 10 Aug 2021 18:10:27 +0800", "author": "", "description": "DBML（Database Markup Language）是一种开源的 DSL 语言，旨在定义和记录数据库模式和结构。它被设计为简单、一致和高度可读。它还配有命令行工具和开源模块，以帮助你在DBML和SQL之间转换。 特点： 它简单、灵活且高度可读 它与数据库无关，专注于基本的数据库结构定义，而不用担心每个数据库的详细语法 在dbdiagram.io提供免费、简单的数据库可视化工具 还附带一个免费的数据库文档应用程序，位于dbdocs.io \nTable users {...", "shortDescription": "DBML（Database Markup Language）是一种开源的 DSL 语言，旨在定义和记录数据库模式和结构。它被设计为简单、一致和高度可读。它还配有命令行工具和开源模块，以帮助你在DBML和SQL之间转换。 特点： 它简单、灵活...", "isRead": false}, {"title": "完全自动化的版本管理和软件包发布 semantic-release", "link": "https://www.oschina.net/p/semantic-release", "time": "Tue, 10 Aug 2021 17:44:00 +0800", "author": "", "description": "semantic-release 将整个软件包的发布工作流程自动化，包括：确定下一个版本号、生成发布说明以及发布软件包。 亮点： 全自动发布 强制执行语义版本控制规范 用户可以立即使用新功能和修复程序 通知维护者和用户新版本 使用正式的提交消息约定来记录代码库中的更改 基于 git merges在不同的分发渠道（例如npm dist-tags）上发布 与整合持续集成的工作流程 避免与手动发布相关的潜在错误 支持任何软件包管理器和语言通过插件 通过...", "shortDescription": "semantic-release 将整个软件包的发布工作流程自动化，包括：确定下一个版本号、生成发布说明以及发布软件包。 亮点： 全自动发布 强制执行语义版本控制规范 用户可以立即使用新功能和修复程序 通知维护者和用户新版本 使用正式的提交...", "isRead": false}, {"title": "3D 打印机固件 Klipper", "link": "https://www.oschina.net/p/klipper", "time": "Tue, 10 Aug 2021 17:27:36 +0800", "author": "", "description": "Klipper是一个3D打印机固件，它结合了通用计算机和一个或多个微控制器的力量。 主要功能： 高精度 stepper movement。Klipper 在计算打印机移动时使用应用处理器（例如低成本的 Raspberry Pi）。应用处理器确定何时步进每个步进电机，它压缩这些事件，将它们传输到微控制器，然后微控制器在请求的时间执行每个事件。每个步进器事件的调度精度为 25 微秒或更高。该软件不使用运动学估计（例如 Bresenham 算法），而是根据加速度物...", "shortDescription": "Klipper是一个3D打印机固件，它结合了通用计算机和一个或多个微控制器的力量。 主要功能： 高精度 stepper movement。Klipper 在计算打印机移动时使用应用处理器（例如低成本的 Raspberry Pi）。应用处理器...", "isRead": false}, {"title": "高效近似近邻搜索算法集合库 hora", "link": "https://www.oschina.net/p/hora", "time": "Tue, 10 Aug 2021 17:16:20 +0800", "author": "", "description": "Hora 是一个近似的近邻搜索算法库。用 Rust 实现了所有的代码，以获得可靠性、高水平的抽象和与 C++ 相当的高速度，这些使它真正适合于人工智能计算场景。 特性： 高性能 SIMD 加速（packed_simd) 稳定的算法实现 多线程设计 多语言支持 Python Javascript Java Go (WIP) Ruby (WIP) Swift (WIP) R (WIP) Julia (WIP) 也可以作为一个 service 多索引支持 Hierarchical Navigable Small World Graph Index(HNSWIndex)（详情) Sat...", "shortDescription": "Hora 是一个近似的近邻搜索算法库。用 Rust 实现了所有的代码，以获得可靠性、高水平的抽象和与 C++ 相当的高速度，这些使它真正适合于人工智能计算场景。 特性： 高性能 SIMD 加速（packed_simd) 稳定的算法实现 多线...", "isRead": false}, {"title": "跨平台的终端/ssh/sftp 客户端 electerm", "link": "https://www.oschina.net/p/electerm", "time": "Tue, 10 Aug 2021 17:13:45 +0800", "author": "", "description": "electerm 是基于 electron/ssh2/node-pty/xterm/antd/subx 和其他 lib 的终端/ssh/sftp 客户端，适用于 Windows、macOS 和 Linux。 特性： 作为一个终端/文件管理器或 ssh/sftp 客户端运作（类似于 xshell）； 全局热键来切换窗口的可见性； 多平台（Linux、Mac、Win）； 支持多国语言； 双击直接编辑远程文件； 用内置编辑器编辑本地文件； 用公钥+密码认证； 透明窗口（Mac、Win）。 终端背景图像； 全局/会话代理； 快速命令...", "shortDescription": "electerm 是基于 electron/ssh2/node-pty/xterm/antd/subx 和其他 lib 的终端/ssh/sftp 客户端，适用于 Windows、macOS 和 Linux。 特性： 作为一个终端/文件管理器...", "isRead": false}, {"title": "GPS 日志文件查看器和分析器 GPXSee", "link": "https://www.oschina.net/p/gpxsee", "time": "Tue, 10 Aug 2021 16:39:45 +0800", "author": "", "description": "GPXSee 是一个基于 Qt 的 GPS 日志文件查看器和分析器，支持所有常见的 GPS 日志文件格式。 特性： 支持打开 GPX、TCX、FIT、KML、NMEA、IGC、CUP、SIGMA SLF、Suunto SML、LOC、GeoJSON 等类型的文件； 用户可定义的在线地图； 离线地图； 海拔、速度、心率、节奏、功率、温度等图表； 支持 DEM 文件； 在一个视图中支持多个轨道； 支持 POI 文件； 打印/导出为 PDF/PNG； 全屏模式； HiDPI/Retina 显示和地图支持； 适用于 Wi...", "shortDescription": "GPXSee 是一个基于 Qt 的 GPS 日志文件查看器和分析器，支持所有常见的 GPS 日志文件格式。 特性： 支持打开 GPX、TCX、FIT、KML、NMEA、IGC、CUP、SIGMA SLF、Suunto SML、LOC、Geo...", "isRead": false}, {"title": "模块化的 Web 框架 Tokio-axum", "link": "https://www.oschina.net/p/tokio-axum", "time": "Tue, 10 Aug 2021 16:25:07 +0800", "author": "", "description": "axum 是一个使用了 Tokio、Tower 和 Hyper，并专注于模块化的 Web 应用程序框架。 其高级功能包括： 用一个无宏的 API 将请求路由到处理程序。 使用提取器对请求进行声明式的解析。 简单且可预测的错误处理模型。 用最小的模板生成响应。 充分利用 tower 和 tower-http 的中间件、服务和工具的生态系统。 特别是最后一点，是 axum 与其他框架不同的地方。axum 没有自己的中间件系统，而是使用 tower::Service。这意味着 axum 可...", "shortDescription": "axum 是一个使用了 Tokio、Tower 和 Hyper，并专注于模块化的 Web 应用程序框架。 其高级功能包括： 用一个无宏的 API 将请求路由到处理程序。 使用提取器对请求进行声明式的解析。 简单且可预测的错误处理模型。 用最...", "isRead": false}, {"title": "基于 Firefox 分支的浏览器 Iceraven", "link": "https://www.oschina.net/p/iceraven", "time": "Tue, 10 Aug 2021 16:02:14 +0800", "author": "", "description": "Iceraven 浏览器是一款基于 Mozilla Firefox 并适用于 Android 的网络浏览器。Iceraven 的目标是成为新的 Firefox for Android 的分支，旨在为用户提供更多选择、更多定制机会（包括广泛的扩展库）等。 值得注意的功能包括： 支持 about:config 能够安装比官方 Firefox for Android 浏览器更多的附加组件。 安装 当前版本是以 .apk 文件的形式发布的，通过 Github 用户可以为 Android 设备下载并安装合适的版本。 确定需要什么版...", "shortDescription": "Iceraven 浏览器是一款基于 Mozilla Firefox 并适用于 Android 的网络浏览器。Iceraven 的目标是成为新的 Firefox for Android 的分支，旨在为用户提供更多选择、更多定制机会（包括广泛的...", "isRead": false}, {"title": "开源任务管理应用 Planner", "link": "https://www.oschina.net/p/planner", "time": "Tue, 10 Aug 2021 15:34:28 +0800", "author": "", "description": "特性： 完全重新设计的用户界面 新图标 随时随地对任务进行排序 每个项目的进度指标 提高工作效率并按“部门”组织任务 可视化活动并更好地计划日程 改进的提醒系统，现在您可以创建一个或多个提醒 更好的黑暗主题 对 Todoist 的支持： 借助 Todoist，同步项目、任务等 支持 Todoist 离线：在没有互联网连接的情况下使用，当重新连接时，将被自动同步 其它功能： 提醒通知 快速查找 夜间模式 重复的到期日 构建 将需要以下依赖项...", "shortDescription": "特性： 完全重新设计的用户界面 新图标 随时随地对任务进行排序 每个项目的进度指标 提高工作效率并按“部门”组织任务 可视化活动并更好地计划日程 改进的提醒系统，现在您可以创建一个或多个提醒 更好的黑暗主题 对 Todoist 的支持： 借...", "isRead": false}, {"title": "Prometheus 监控可视化仪表板 KUR8", "link": "https://www.oschina.net/p/kur8", "time": "Tue, 10 Aug 2021 14:00:44 +0800", "author": "", "description": "KUR8 是一个开源的 Prometheus 监控可视化仪表板，兼容 PromQL，可查询指标、查看告警、创建自定义图表。", "shortDescription": "KUR8 是一个开源的 Prometheus 监控可视化仪表板，兼容 PromQL，可查询指标、查看告警、创建自定义图表。", "isRead": false}]}]